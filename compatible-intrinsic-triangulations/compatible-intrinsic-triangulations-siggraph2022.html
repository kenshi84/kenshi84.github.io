
<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Compatible Intrinsic Triangulations</title>
<!--Generated on Thu Nov 21 12:05:35 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->

<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="ltx-amsart.css" type="text/css">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="keywords" lang="en" content="cross-parameterization,  inter-surface mapping,  bijection,  texture transfer,  intrinsic triangulation,  compatible triangulation">
<base href="./png/" target="_blank">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line ltx_leqno">
<figure id="S0.F1" class="ltx_figure ltx_teaserfigure"><img src="x1.png" id="S0.F1.g1" class="ltx_graphics ltx_img_landscape" width="830" height="197" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 1. </span>
Given two triangle meshes <math id="S0.F1.m7" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S0.F1.m8" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>, we find a continuous, bijective and low-distortion map between them (their edge images shown in (a)).
Internally, we build a Compatible Intrinsic Triangulation (CIT), a pair of intrinsic triangulations on both models sharing the same connectivity; every vertex of <math id="S0.F1.m9" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> is inserted to <math id="S0.F1.m10" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic mesh, and vice versa (b).
Our algorithm generates a piecewise-linear map in the form of overlay polygons; here, <math id="S0.F1.m11" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s texture is being transferred to <math id="S0.F1.m12" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> with all the seams preserved (c).
</figcaption>
</figure>
<h1 class="ltx_title ltx_title_document">Compatible Intrinsic Triangulations</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Kenshi Takayama
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_email"><a href="mailto:kenshi84@gmail.com">kenshi84@gmail.com</a>
</span>
<span class="ltx_contact ltx_role_orcid"><a href="https://orcid.org/0000-0003-0156-1136" title="ORCID identifier" class="ltx_ref">0000-0003-0156-1136</a></span>

<span class="ltx_contact ltx_role_affiliation"><span class="ltx_text ltx_affiliation_institution">National Institute of Informatics / CyberAgent</span><span class="ltx_text ltx_affiliation_country">Japan</span>
</span></span></span>
</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract.</h6>
<p class="ltx_p">Finding distortion-minimizing homeomorphisms between surfaces of arbitrary genus is a fundamental task in computer graphics and geometry processing.
We propose a simple method utilizing intrinsic triangulations, operating directly on the original surfaces without going through any intermediate domains such as a plane or a sphere.

Given two models <math id="m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> as triangle meshes, our algorithm constructs a <em class="ltx_emph ltx_font_italic">Compatible Intrinsic Triangulation</em> (CIT), a pair of intrinsic triangulations over <math id="m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> with full correspondences in their vertices, edges and faces.
Such a tessellation allows us to establish consistent images of edges and faces of <math id="m5" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s input mesh over <math id="m6" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> (and vice versa) by tracing piecewise-geodesic paths over <math id="m7" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="m8" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>.
Our algorithm for constructing CITs, primarily consisting of carefully designed edge flipping schemes, is empirical in nature without any guarantee of success, but turns out to be robust enough to be used within a similar second-order optimization framework as was used previously in the literature.
The utility of our method is demonstrated through comparisons and evaluation on a standard benchmark dataset.</p>
</div>
<div class="ltx_keywords">cross-parameterization, inter-surface mapping, bijection, texture transfer, intrinsic triangulation, compatible triangulation
</div>
<span class="ltx_note ltx_note_frontmatter ltx_role_copyright"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">copyright: </span>othergov</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_journal"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">journal: </span>TOG</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_journalyear"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">journalyear: </span>2022</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_journalvolume"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">journalvolume: </span>41</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_journalnumber"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">journalnumber: </span>4</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_article"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">article: </span>57</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_publicationmonth"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">publicationmonth: </span>7</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_doi"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">doi: </span>10.1145/3528223.3530175</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_submissionid"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">submissionid: </span>papers_703</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_ccs"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">ccs: </span>Computing methodologies Mesh models</span></span></span><span class="ltx_note ltx_note_frontmatter ltx_role_ccs"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">ccs: </span>Computing methodologies Mesh geometry models</span></span></span>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1. </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p class="ltx_p">Computing maps between surfaces is needed in many contexts, and has been a classical topic of great importance in computer graphics and geometry processing.
In particular, maps that are continuous and bijective, called <em class="ltx_emph ltx_font_italic">homeomorphisms</em>, are required for many applications such as texture transfer and template fitting in order to avoid various kinds of artifacts, but at the same time they are generally more difficult to compute than other relaxed versions of maps.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p class="ltx_p">Given two surfaces <math id="S1.p2.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S1.p2.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> as triangle meshes, a naive and intuitive idea one might think of is as follows:</p>
<ol id="S1.I1" class="ltx_enumerate">
<li id="S1.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(1)</span> 
<div id="S1.I1.i1.p1" class="ltx_para">
<p class="ltx_p">map <math id="S1.I1.i1.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertices onto <math id="S1.I1.i1.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> somehow, e.g., by using some form of projection, then</p>
</div>
</li>
<li id="S1.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(2)</span> 
<div id="S1.I1.i2.p1" class="ltx_para">
<p class="ltx_p">extend the above vertex-based map to <math id="S1.I1.i2.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s edges and faces somehow, e.g., by using geodesics on <math id="S1.I1.i2.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>.</p>
</div>
</li>
</ol>
<p class="ltx_p">If one pursued the above idea while working directly on the original surfaces, however, they would quickly realize that things get complicated.
As such, all previous works introduce an <em class="ltx_emph ltx_font_italic">intermediate domain</em> such as a plane or a sphere and establish homeomorphisms by going through that intermediate domain.
The method proposed by Schmidt et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> is the current state of the art in this area, where the surfaces are locally mapped to an intermediate domain in a globally consistent manner by using constant-curvature metrics.
While their theory is elegant and results are impressive, their approach is conceptually not so intuitive, potentially making its implementation difficult for non-expert practitioners.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p class="ltx_p">In this work, we present a simpler alternative that pursues the above intuitive idea using <em class="ltx_emph ltx_font_italic">intrinsic triangulations</em> <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite> as our key ingredient.
We propose <em class="ltx_emph ltx_font_italic">Compatible Intrinsic Triangulation</em> (CIT), a pair of intrinsic triangulations defined on <math id="S1.p3.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S1.p3.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> where the vertices, edges and faces are fully in correspondence (Fig. <a href="#S0.F1" title="Figure 1 ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>).
Given vertex images as input, our algorithm constructs a CIT by employing carefully designed edge flipping schemes and other local operations (Sec. <a href="#S4" title="4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>).
CITs define strict homeomorphisms, and allow one to easily compute mapping distortions and their derivatives as well as to optimize the vertex images by using the similar second-order global optimization scheme as was used in the previous work <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> (Sec. <a href="#S6" title="6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>).</p>
</div>
<div id="S1.p4" class="ltx_para">
<p class="ltx_p">We do not claim, however, any practical advantages over Schmidt et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>’s method.
In fact, our method is less robust than theirs in the sense that it relies on the input vertex images being sufficiently high-quality; otherwise, our algorithm can fail, as discussed in Sec. <a href="#S7" title="7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>.
Nevertheless, to the best of our knowledge, our work is the first in the literature on computing surface homeomorphisms without going through any intermediate domains.
In exchange for the conceptual simplicity and intuitiveness of our approach, we had to deal with a number of combinatorial problems which make our algorithm inherently empirical and heuristic, providing no guarantee for success.
Yet, our algorithm is overall straightforward to implement, and we experimentally demonstrate practical level of robustness of our method using a standard benchmark dataset (Sec. <a href="#S7.SS3" title="7.3. Evaluation with Princeton Segmentation Dataset ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7.3</span></a>).</p>
</div>
<div id="S1.p5" class="ltx_para">
<p class="ltx_p">We believe it is natural to utilize intrinsic triangulations for the purely intrinsic problem of inter-surface mappings.
The two research domains have received increased attentions in the community recently, but only in separate, unrelated contexts.
This work aims at bridging the two, thereby inspiring other researchers to develop new solutions to this difficult problem.
In this light, we release our reference implementation at <a href="https://github.com/kenshi84/compatible-intrinsic-triangulations" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://github.com/kenshi84/compatible-intrinsic-triangulations</a>.</p>
</div>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2. </span>Related work</h2>

<div id="S2.p1" class="ltx_para">
<p class="ltx_p">There are a large body of work on computing maps between surfaces, and they can be roughly divided into two groups based on whether strict homeomorphism is sought after or not.
Those which do not seek for homeomorphism seem more popular, presumably because it is easier to represent and optimize maps in this setting.
A variety of methods have been proposed including:</p>
<ul id="S2.I1" class="ltx_itemize">
<li id="S2.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I1.i1.p1" class="ltx_para">
<p class="ltx_p">projection-based methods <cite class="ltx_cite ltx_citemacro_citep">(Ezuz<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib5" title="Elastic correspondence between triangle meshes" class="ltx_ref">2019a</a>, <a href="#bib.bib6" title="Reversible harmonic maps between discrete surfaces" class="ltx_ref">b</a>; Panozzo<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib7" title="Weighted averages on surfaces" class="ltx_ref">2013</a>)</cite>,</p>
</div>
</li>
<li id="S2.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I1.i2.p1" class="ltx_para">
<p class="ltx_p">distribution-based methods <cite class="ltx_cite ltx_citemacro_citep">(Ovsjanikov<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib8" title="Functional maps: a flexible representation of maps between shapes" class="ltx_ref">2012</a>; Solomon<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib9" title="Soft maps between surfaces" class="ltx_ref">2012</a>; Mandad<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib10" title="Variance-minimizing transport plans for inter-surface mapping" class="ltx_ref">2017</a>)</cite>, and</p>
</div>
</li>
<li id="S2.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I1.i3.p1" class="ltx_para">
<p class="ltx_p">methods developed in the context of surface registration <cite class="ltx_cite ltx_citemacro_citep">(Huang<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib11" title="Non-rigid registration under isometric deformations" class="ltx_ref">2008</a>; Bouaziz<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib12" title="Sparse iterative closest point" class="ltx_ref">2013</a>; Sharf<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib13" title="SnapPaste: an interactive technique for easy mesh composition" class="ltx_ref">2006</a>; Tam<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib14" title="Registration of 3d point clouds and meshes: a survey from rigid to nonrigid" class="ltx_ref">2013</a>; Wu<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib15" title="Consistent correspondence between arbitrary manifold surfaces" class="ltx_ref">2007</a>; Yang<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib16" title="Volume-enhanced compatible remeshing of 3d models" class="ltx_ref">2019</a>, <a href="#bib.bib17" title="Error-bounded compatible remeshing" class="ltx_ref">2020</a>; Zhang<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib18" title="Manifold parameterization" class="ltx_ref">2006</a>)</cite>.</p>
</div>
</li>
</ul>
<p class="ltx_p">While there are many use cases for these relaxed maps, turning them into actual homeomorphisms is a non-trivial, open problem.</p>
</div>
<div id="S2.p2" class="ltx_para">
<p class="ltx_p">Computing homeomorphisms between surfaces is generally more difficult, and usually an intermediate domain is used in order to define the final map as a composition of individual maps between surfaces and the intermediate domain.
Examples of intermediate domains include:</p>
<ul id="S2.I2" class="ltx_itemize">
<li id="S2.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I2.i1.p1" class="ltx_para">
<p class="ltx_p">a plane <cite class="ltx_cite ltx_citemacro_citep">(Aigerman<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib19" title="Lifted bijections for low distortion surface mappings" class="ltx_ref">2014</a>; Aigerman and Lipman, <a href="#bib.bib20" title="Orbifold tutte embeddings" class="ltx_ref">2015</a>; Aigerman<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib21" title="Seamless surface mappings" class="ltx_ref">2015</a>; Kanai<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib22" title="3D geometric metamorphosis based on harmonic map" class="ltx_ref">1997</a>; Kim<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib23" title="Blended intrinsic maps" class="ltx_ref">2011</a>; Lipman and Funkhouser, <a href="#bib.bib24" title="Möbius voting for surface correspondence" class="ltx_ref">2009</a>; Litke<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib25" title="An Image Processing Approach to Surface Matching" class="ltx_ref">2005</a>; Tierny<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib26" title="Inspired quadrangulation" class="ltx_ref">2011</a>; Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>)</cite>,</p>
</div>
</li>
<li id="S2.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I2.i2.p1" class="ltx_para">
<p class="ltx_p">a sphere <cite class="ltx_cite ltx_citemacro_citep">(Aigerman<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib27" title="Spherical orbifold tutte embeddings" class="ltx_ref">2017</a>; Baden<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib28" title="Möbius registration" class="ltx_ref">2018</a>; Alexa, <a href="#bib.bib29" title="Merging polyhedral shapes with scattered features" class="ltx_ref">2000</a>; Asirvatham<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib30" title="Consistent spherical parameterization" class="ltx_ref">2005</a>)</cite>,</p>
</div>
</li>
<li id="S2.I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I2.i3.p1" class="ltx_para">
<p class="ltx_p">a hyperbolic plane <cite class="ltx_cite ltx_citemacro_citep">(Aigerman and Lipman, <a href="#bib.bib31" title="Hyperbolic orbifold tutte embeddings" class="ltx_ref">2016</a>; Shi<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib32" title="Hyperbolic harmonic mapping for surface registration" class="ltx_ref">2017</a>)</cite>, and</p>
</div>
</li>
<li id="S2.I2.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S2.I2.i4.p1" class="ltx_para">
<p class="ltx_p">base complexes <cite class="ltx_cite ltx_citemacro_citep">(Praun<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib35" title="Consistent mesh parameterizations" class="ltx_ref">2001</a>; Schreiner<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib33" title="Inter-surface mapping" class="ltx_ref">2004</a>; Kraevoy and Sheffer, <a href="#bib.bib34" title="Cross-parameterization and compatible remeshing of 3d models" class="ltx_ref">2004</a>)</cite>.</p>
</div>
</li>
</ul>
<p class="ltx_p">Among the above, only a very few address the problem of minimizing the map distortion in an end-to-end manner.
Methods by Schreiner et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib33" title="Inter-surface mapping" class="ltx_ref">2004</a>)</cite> and Kraevoy et al.  <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib34" title="Cross-parameterization and compatible remeshing of 3d models" class="ltx_ref">2004</a>)</cite> only allow local optimization per each vertex’s 1-ring neighborhood, and are prone to converging to undesirable local minima.
Methods by Litke et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib25" title="An Image Processing Approach to Surface Matching" class="ltx_ref">2005</a>)</cite> and Schmidt et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>)</cite> do offer global optimization, but they are applicable only to surfaces of disk topology.</p>
</div>
<div id="S2.p3" class="ltx_para">
<p class="ltx_p">Distortion minimization of homeomorphisms between closed surfaces of arbitrary genus in a global and end-to-end manner was addressed only recently by Schmidt et al <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>.
Our problem setting is exactly the same, and our results are similar with theirs.
Unlike their method where surfaces are locally mapped to a respective intermediate domain (either a plane, a sphere, or a hyperbolic plane, depending on the surface genus) by using constant-curvature metrics, our method constructs consistent mappings between surfaces directly on the original surfaces without going through any intermediate domains by using intrinsic triangulations <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>, which we believe leads to a simpler (albeit heuristic) algorithm.</p>
</div>
<section id="S2.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Intrinsic triangulations</h5>

<div id="S2.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">Our work is directly inspired by the powerful concept of intrinsic triangulations based on the signpost data structure <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>, which has already found a number of extensions and use cases in the literature.
Sharp and Crane <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib38" title="A laplacian for nonmanifold triangle meshes" class="ltx_ref">2020a</a>)</cite> utilized it for defining a high-quality Laplacian operator on non-manifold meshes as well as point clouds.
Sharp and Crane <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib39" title="You can find geodesic paths in triangle meshes by just flipping edges" class="ltx_ref">2020b</a>)</cite> also demonstrated that one can find polyhedral geodesics on surfaces by just flipping edges intrinsically.
The intrinsic Delaunay triangulation algorithm has already been used for various geometry processing tasks <cite class="ltx_cite ltx_citemacro_citep">(El Ouafdi<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib37" title="Adaptive estimation of hodge star operator on simplicial surfaces" class="ltx_ref">2021</a>; Fumero<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib36" title="Nonlinear spectral geometry processing via the tv transform" class="ltx_ref">2020</a>; Tao<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib40" title="Parallel and scalable heat methods for geodesic distance computation" class="ltx_ref">2021</a>)</cite>.
Our work widens the application domains of intrinsic triangulations to the problem of inter-surface mappings.</p>
</div>
</section>
<section id="S2.SS0.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Compatible triangulations for 2D animation</h5>

<div id="S2.SS0.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">Our algorithm for constructing CITs is mainly about deciding which edges to flip based on the configuration of nearby vertices in a local 2D coordinate system, and thus is quite related to the existing literature on compatible triangulations in the context of 2D animation <cite class="ltx_cite ltx_citemacro_citep">(Alexa<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib41" title="As-rigid-as-possible shape interpolation" class="ltx_ref">2000</a>; Surazhsky and Gotsman, <a href="#bib.bib44" title="High quality compatible triangulations" class="ltx_ref">2004</a>; Baxter III<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib42" title="Compatible embedding for 2d shape animation" class="ltx_ref">2009</a>; Liu<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib43" title="High-quality compatible triangulations and their application in interactive animation" class="ltx_ref">2018</a>)</cite>.
Revisiting these algorithms in our context may lead to substantial improvement of our algorithm, which is left for future work.</p>
</div>
<figure id="S2.F2" class="ltx_figure"><img src="x2.png" id="S2.F2.g1" class="ltx_graphics ltx_img_landscape" width="831" height="202" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 2. </span>
The vertex insertion step (left) followed by the intrinsic Delaunay flipping step (right).
Each vertex in correspondence is drawn in its unique color, and each original (i.e., non-inserted) vertex is drawn with a black silhouette.
A merged vertex is drawn as a larger ball.
The vertex highlighted by the red arrow originates in <math id="S2.F2.m3" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> and is inserted to <math id="S2.F2.m4" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s input edge, splitting the two adjacent intrinsic faces.
Each compatible edge (i.e., connecting the same pair of corresponding vertices) is drawn in its unique color, while each incompatible edge is drawn in dark gray.
Notice how the intrinsic Delaunay flipping step reduces the number of incompatible edges significantly.
</figcaption>
</figure>
</section>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3. </span>Overview</h2>

<div id="S3.p1" class="ltx_para">
<p class="ltx_p">Our input consists of a pair of triangle meshes <math id="S3.p1.m1" class="ltx_Math" alttext="M_{\mathtt{A}}=(V_{\mathtt{A}},E_{\mathtt{A}},F_{\mathtt{A}})" display="inline"><mrow><msub><mi>M</mi><mi>𝙰</mi></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>𝙰</mi></msub><mo>,</mo><msub><mi>E</mi><mi>𝙰</mi></msub><mo>,</mo><msub><mi>F</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> and <math id="S3.p1.m2" class="ltx_Math" alttext="M_{\mathtt{B}}=(V_{\mathtt{B}},E_{\mathtt{B}},F_{\mathtt{B}})" display="inline"><mrow><msub><mi>M</mi><mi>𝙱</mi></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>𝙱</mi></msub><mo>,</mo><msub><mi>E</mi><mi>𝙱</mi></msub><mo>,</mo><msub><mi>F</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> for the two models, along with <math id="S3.p1.m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex image <math id="S3.p1.m4" class="ltx_Math" alttext="\phi_{\mathtt{A}\rightarrow\mathtt{B}}:V_{\mathtt{A}}\mapsto F_{\mathtt{B}}\times\Lambda" display="inline"><mrow><msub><mi>ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo lspace="0.278em" rspace="0.278em">:</mo><mrow><msub><mi>V</mi><mi>𝙰</mi></msub><mo stretchy="false">↦</mo><mrow><msub><mi>F</mi><mi>𝙱</mi></msub><mo lspace="0.222em" rspace="0.222em">×</mo><mi mathvariant="normal">Λ</mi></mrow></mrow></mrow></math>, with <math id="S3.p1.m5" class="ltx_Math" alttext="\Lambda=\{(\lambda_{1},\lambda_{2},\lambda_{3})|\sum_{i}\lambda_{i}=1\}\subset%
\mathbb{R}^{3}" display="inline"><mrow><mi mathvariant="normal">Λ</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><mo lspace="0em" rspace="0em">|</mo><mrow><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>λ</mi><mi>i</mi></msub></mrow><mo>=</mo><mn>1</mn></mrow><mo stretchy="false">}</mo></mrow><mo>⊂</mo><msup><mi>ℝ</mi><mn>3</mn></msup></mrow></math> being the space of barycentric coordinates, which maps <math id="S3.p1.m6" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex to a point inside <math id="S3.p1.m7" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s face, and the other one in the opposite direction <math id="S3.p1.m8" class="ltx_Math" alttext="\phi_{\mathtt{B}\rightarrow\mathtt{A}}" display="inline"><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub></math>.
Any method of choice can be used to obtain these vertex images, such as the Hyperbolic Orbifold Tutte (HOT) method <cite class="ltx_cite ltx_citemacro_citep">(Aigerman and Lipman, <a href="#bib.bib31" title="Hyperbolic orbifold tutte embeddings" class="ltx_ref">2016</a>)</cite>; the only requirement is that they need to be reasonably consistent in both directions in order for our algorithm to succeed.
Given such input data, our algorithm generates a Compatible Intrinsic Triangulation (CIT), as explained in Sec. <a href="#S4" title="4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>.</p>
</div>
<div id="S3.p2" class="ltx_para">
<p class="ltx_p">In Sec. <a href="#S5" title="5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, we explain how to process the generated CIT further in order to obtain images of <math id="S3.p2.m1" class="ltx_Math" alttext="E_{\mathtt{A}}" display="inline"><msub><mi>E</mi><mi>𝙰</mi></msub></math> on <math id="S3.p2.m2" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math> and vice versa as piecewise-geodesic polylines, as well as the piecewise-linear mapping between <math id="S3.p2.m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S3.p2.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> as an overlay mesh.</p>
</div>
<div id="S3.p3" class="ltx_para">
<p class="ltx_p">From the generated CIT, we compute the map’s distortion energy and its derivatives using automatic differentiation, just like the previous method <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>.
We displace the current vertex images by the computed descent direction multiplied by a certain step size, and plug them into our CIT generation algorithm again to arrive at a new configuration.
We explain this optimization process in Sec. <a href="#S6" title="6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.</p>
</div>
<section id="S3.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Notations</h5>

<div id="S3.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">We use a bold font style to distinguish the intrinsic mesh and its elements from the input mesh and its elements on either model.
For example, <math id="S3.SS0.SSS0.Px1.p1.m1" class="ltx_Math" alttext="v_{\mathtt{A}}\in V_{\mathtt{A}}" display="inline"><mrow><msub><mi>v</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>V</mi><mi>𝙰</mi></msub></mrow></math> refers to a vertex of <math id="S3.SS0.SSS0.Px1.p1.m2" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s input mesh, while <math id="S3.SS0.SSS0.Px1.p1.m3" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}\in\mathbf{E}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙱</mi></msub></mrow></math> refers to an edge of <math id="S3.SS0.SSS0.Px1.p1.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic mesh.</p>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4. </span>CIT generation</h2>

<section id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.1. </span>Vertex insertion</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p class="ltx_p">After initializing intrinsic meshes <math id="S4.SS1.p1.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS1.p1.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> as copies of input meshes <math id="S4.SS1.p1.m3" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS1.p1.m4" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math>, we first insert <math id="S4.SS1.p1.m5" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s input vertices <math id="S4.SS1.p1.m6" class="ltx_Math" alttext="V_{\mathtt{A}}" display="inline"><msub><mi>V</mi><mi>𝙰</mi></msub></math> into <math id="S4.SS1.p1.m7" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> according to the vertex image <math id="S4.SS1.p1.m8" class="ltx_Math" alttext="\phi_{\mathtt{A}\rightarrow\mathtt{B}}" display="inline"><msub><mi>ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub></math>.
For each input vertex <math id="S4.SS1.p1.m9" class="ltx_Math" alttext="v_{\mathtt{A}}\in V_{\mathtt{A}}" display="inline"><mrow><msub><mi>v</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>V</mi><mi>𝙰</mi></msub></mrow></math>, we check if its image <math id="S4.SS1.p1.m10" class="ltx_Math" alttext="\phi_{\mathtt{A}\rightarrow\mathtt{B}}(v_{\mathtt{A}})=(f_{\mathtt{B}},\bm{%
\lambda})" display="inline"><mrow><mrow><msub><mi>ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>𝙱</mi></msub><mo>,</mo><mi>𝝀</mi><mo stretchy="false">)</mo></mrow></mrow></math> is strictly inside <math id="S4.SS1.p1.m11" class="ltx_Math" alttext="f_{\mathtt{B}}" display="inline"><msub><mi>f</mi><mi>𝙱</mi></msub></math>, i.e., if <math id="S4.SS1.p1.m12" class="ltx_Math" alttext="\lambda_{i}&gt;0,\forall i" display="inline"><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>&gt;</mo><mrow><mn>0</mn><mo>,</mo><mrow><mo rspace="0.167em">∀</mo><mi>i</mi></mrow></mrow></mrow></math> (we call such a mapped point a <em class="ltx_emph ltx_font_italic">face point</em>).
If so, we insert a new vertex into an intrinsic face <math id="S4.SS1.p1.m13" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}\in\mathbf{F}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐅</mi><mi>𝙱</mi></msub></mrow></math> corresponding to that face point, splitting <math id="S4.SS1.p1.m14" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math> into three.</p>
</div>
<div id="S4.SS1.p2" class="ltx_para">
<p class="ltx_p">If one component of <math id="S4.SS1.p2.m1" class="ltx_Math" alttext="\{\lambda_{i}\}" display="inline"><mrow><mo stretchy="false">{</mo><msub><mi>λ</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></math> is zero, the mapped point is exactly on <math id="S4.SS1.p2.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s input edge <math id="S4.SS1.p2.m3" class="ltx_Math" alttext="e_{\mathtt{B}}\in E_{\mathtt{B}}" display="inline"><mrow><msub><mi>e</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>E</mi><mi>𝙱</mi></msub></mrow></math> (we call such a mapped point an <em class="ltx_emph ltx_font_italic">edge point</em>).
In this case, we insert a new vertex into an intrinsic edge <math id="S4.SS1.p2.m4" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}\in\mathbf{E}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙱</mi></msub></mrow></math> corresponding to that edge point, splitting <math id="S4.SS1.p2.m5" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> into two.</p>
</div>
<div id="S4.SS1.p3" class="ltx_para">
<p class="ltx_p">If two components of <math id="S4.SS1.p3.m1" class="ltx_Math" alttext="\{\lambda_{i}\}" display="inline"><mrow><mo stretchy="false">{</mo><msub><mi>λ</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></math> are zero, this means <math id="S4.SS1.p3.m2" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex <math id="S4.SS1.p3.m3" class="ltx_Math" alttext="v_{\mathtt{A}}" display="inline"><msub><mi>v</mi><mi>𝙰</mi></msub></math> is mapped exactly onto <math id="S4.SS1.p3.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s vertex <math id="S4.SS1.p3.m5" class="ltx_Math" alttext="v_{\mathtt{B}}" display="inline"><msub><mi>v</mi><mi>𝙱</mi></msub></math>, i.e., <math id="S4.SS1.p3.m6" class="ltx_Math" alttext="\phi_{\mathtt{A}\rightarrow\mathtt{B}}(v_{\mathtt{A}})=v_{\mathtt{B}}" display="inline"><mrow><mrow><msub><mi>ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>v</mi><mi>𝙱</mi></msub></mrow></math>.
In this case, we ensure that the vertex image in the opposite direction is consistent, i.e., <math id="S4.SS1.p3.m7" class="ltx_Math" alttext="\phi_{\mathtt{B}\rightarrow\mathtt{A}}(v_{\mathtt{B}})=v_{\mathtt{A}}" display="inline"><mrow><mrow><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>v</mi><mi>𝙰</mi></msub></mrow></math>.
We conceptually interpret such a case as the original vertex and the inserted vertex being <em class="ltx_emph ltx_font_italic">merged</em> in the intrinsic mesh, and we do not insert a new vertex in this case.
In our method, we achieve hard constraints on a set of fixed corresponding vertex pairs by keeping them as merged (we call such fixed vertices <em class="ltx_emph ltx_font_italic">anchors</em>).
If not using this hard constraints mode, we will later split each merged vertex into two (as explained in Sec. <a href="#S4.SS7" title="4.7. Splitting merged vertices ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.7</span></a>) in order to treat the two vertices as variables in the optimization.</p>
</div>
<div id="S4.SS1.p4" class="ltx_para">
<p class="ltx_p">Additionally, we introduce the following adjustment procedure for stability reasons: when all of <math id="S4.SS1.p4.m1" class="ltx_Math" alttext="\{\lambda_{i}\}" display="inline"><mrow><mo stretchy="false">{</mo><msub><mi>λ</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></math> are positive but one component is extremely small, the mapped face point is almost on one of the edges of the mapped face.
Having an intrinsic vertex at a face point extremely close to an input edge causes numerical instability for our overlay mesh extraction algorithm.
As such, we clamp the smallest value below a threshold to zero and increase the other two components to sum to one, and treat it as an edge point.</p>
</div>
<div id="S4.SS1.p5" class="ltx_para">
<p class="ltx_p">We perform the same vertex insertion process in the opposite direction (<math id="S4.SS1.p5.m1" class="ltx_Math" alttext="\mathtt{B}\rightarrow\mathtt{A}" display="inline"><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></math>) as well.</p>
</div>
<figure id="S4.F3" class="ltx_figure"><img src="x3.png" id="S4.F3.g1" class="ltx_graphics ltx_img_landscape" width="830" height="102" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 3. </span>
Five subroutines constituting our <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> algorithm.
</figcaption>
</figure>
</section>
<section id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.2. </span>Compatible edges &amp; faces</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p class="ltx_p">After the vertex insertion step, the intrinsic meshes <math id="S4.SS2.p1.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> have the exact same numbers of vertices, edges and faces.
Also, the intrinsic vertices of both models <math id="S4.SS2.p1.m3" class="ltx_Math" alttext="\mathbf{V}_{\mathtt{A}}" display="inline"><msub><mi>𝐕</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m4" class="ltx_Math" alttext="\mathbf{V}_{\mathtt{B}}" display="inline"><msub><mi>𝐕</mi><mi>𝙱</mi></msub></math> are fully in correspondence.
If the endpoints of <math id="S4.SS2.p1.m5" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edge <math id="S4.SS2.p1.m6" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}\in\mathbf{E}_{\mathtt{A}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙰</mi></msub></mrow></math> correspond to the endpoints of <math id="S4.SS2.p1.m7" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic edge <math id="S4.SS2.p1.m8" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}\in\mathbf{E}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙱</mi></msub></mrow></math>, we say <math id="S4.SS2.p1.m9" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m10" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> are <em class="ltx_emph ltx_font_italic">compatible</em>.
If no such intrinsic edge in <math id="S4.SS2.p1.m11" class="ltx_Math" alttext="\mathbf{E}_{\mathtt{B}}" display="inline"><msub><mi>𝐄</mi><mi>𝙱</mi></msub></math> exists, we say <math id="S4.SS2.p1.m12" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> is <em class="ltx_emph ltx_font_italic">incompatible</em>.
We can further define the notion of face compatibility: if all the three edges of <math id="S4.SS2.p1.m13" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic face <math id="S4.SS2.p1.m14" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}\in\mathbf{F}_{\mathtt{A}}" display="inline"><mrow><msub><mi>𝐟</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>𝐅</mi><mi>𝙰</mi></msub></mrow></math> are compatible, and if there exists <math id="S4.SS2.p1.m15" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic face <math id="S4.SS2.p1.m16" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}\in\mathbf{F}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐅</mi><mi>𝙱</mi></msub></mrow></math> having the same set of compatible edges in the consistent order, then we say <math id="S4.SS2.p1.m17" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m18" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math> are compatible.
If <math id="S4.SS2.p1.m19" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math> has the same set of compatible edges but in the reversed order, we say <math id="S4.SS2.p1.m20" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m21" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math> are <em class="ltx_emph ltx_font_italic">reversed</em>.
If an intrinsic face is neither compatible nor reversed, we say it is incompatible.
If all the intrinsic edges are compatible, all the intrinsic faces will be compatible by necessity.
Our goal is to reach this state by mutating <math id="S4.SS2.p1.m22" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS2.p1.m23" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> in certain ways.</p>
</div>
<div id="S4.SS2.p2" class="ltx_para">
<p class="ltx_p">Fig. <a href="#S2.F2" title="Figure 2 ‣ Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> left shows an example state after the vertex insertion step.
We draw each vertex in correspondence as well as each compatible edge in their unique color, while we draw each incompatible edge in dark gray.
Notice that only some fraction of the edges are compatible at this point.</p>
</div>
<div id="S4.SS2.p3" class="ltx_para">
<p class="ltx_p">There are some rules about intrinsic edges that must be adhered to in our algorithm:
first, we do not allow self-edges, i.e., edges starting from and ending at the same vertex.
We also do not allow multiple intrinsic edges connecting the same pair of intrinsic vertices, because they prevent the definition of one-to-one correspondence between <math id="S4.SS2.p3.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edge and <math id="S4.SS2.p3.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic edge.
These rules imply that every intrinsic vertex always has degree greater than two.
In the following where we flip intrinsic edges, in addition to the geometric feasibility check in the original signpost method <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>, we perform this uniqueness check in order to determine flippability of intrinsic edges.</p>
</div>
</section>
<section id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.3. </span>Delaunay flipping</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p class="ltx_p">The first step in improving our meshes’ compatibility is to perform the intrinsic Delaunay flipping algorithm <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite> on both intrinsic meshes <math id="S4.SS3.p1.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS3.p1.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> independently.
When the input vertex images are reasonably consistent in both directions, the intrinsic vertices <math id="S4.SS3.p1.m3" class="ltx_Math" alttext="\mathbf{V}_{\mathtt{A}}" display="inline"><msub><mi>𝐕</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS3.p1.m4" class="ltx_Math" alttext="\mathbf{V}_{\mathtt{B}}" display="inline"><msub><mi>𝐕</mi><mi>𝙱</mi></msub></math> tend to have vertex neighborhoods in similar geometric configurations, thus the Delaunay flipping procedures on both models tend to result in similar connectivities.
Often, this step already makes a significant portion of the intrinsic edges compatible (Fig. <a href="#S2.F2" title="Figure 2 ‣ Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> right).</p>
</div>
</section>
<section id="S4.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.4. </span>Merging nearby vertices</h3>

<div id="S4.SS4.p1" class="ltx_para">
<p class="ltx_p">An extremely short intrinsic edge in a CIT can be a source of numerical problems both for the computation of the energy derivatives and for the generation of the overlay mesh.
The Delaunay flipping algorithm tends to have connected such nearby vertex pairs as compatible edges.
Such extremely short intrinsic edges also tend to be <em class="ltx_emph ltx_font_italic">collapsible</em>, i.e., its endpoints consist of an original vertex and an inserted vertex, as they are usually caused by the input vertex images mapping <math id="S4.SS4.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex very close to <math id="S4.SS4.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s vertex and vice versa.</p>
</div>
<div id="S4.SS4.p2" class="ltx_para">
<p class="ltx_p">As such, before proceeding to our main algorithm for improving compatibility as described below, we collapse each of such collapsible compatible edges whose length is below a threshold and turn them into a merged vertex.
This edge collapse operation is realized by deleting the inserted vertex and reconnecting all of its adjacent edges to the original vertex.</p>
</div>
</section>
<section id="S4.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.5. </span><span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> algorithm</h3>

<div id="S4.SS5.p1" class="ltx_para">
<p class="ltx_p">In this section, we describe our <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> algorithm which tries to make <math id="S4.SS5.p1.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS5.p1.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> as compatible as possible by just flipping edges.
Note that it is rare to obtain a valid CIT with this algorithm alone, especially when the input vertex images start to deviate from being mutually consistent (which happens when we examine large step sizes during optimization), and we will need to resort to some additional procedures that involve relocation of inserted vertices, as we explain later.
We do prefer, however, to utilize edge flips maximally to improve compatibility, because we do not want to modify the input vertex images unnecessarily.</p>
</div>
<div id="S4.SS5.p2" class="ltx_para">
<p class="ltx_p">Our algorithm consists of five subroutines (Fig. <a href="#S4.F3" title="Figure 3 ‣ 4.1. Vertex insertion ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>), and it executes each of them in order.
If a certain subroutine was able to increase the number of compatible edges, it goes back to the beginning and repeats until no more changes can be made.
In the following, we explain each of the subroutines in the order of the more frequently applicable to the less frequent.
The less frequent ones take effect only occasionally, but they do increase the chance of success of our CIT generation algorithm and are thus necessary.</p>
</div>
<div id="S4.SS5.p3" class="ltx_para">
<p class="ltx_p">Below, when deciding whether to flip an edge or not, we assume it is flippable (i.e., we ignore edges that are not flippable).</p>
</div>
<section id="S4.SS5.SSSx1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">Subroutine 1: <span class="ltx_text ltx_font_smallcaps">SimpleFlip</span>
</h4>

<div id="S4.SS5.SSSx1.p1" class="ltx_para">
<p class="ltx_p">For <math id="S4.SS5.SSSx1.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s incompatible edge <math id="S4.SS5.SSSx1.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}\in\mathbf{E}_{\mathtt{A}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙰</mi></msub></mrow></math>, we check its opposite vertices, and if there is an incompatible edge <math id="S4.SS5.SSSx1.p1.m3" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}\in\mathbf{E}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐄</mi><mi>𝙱</mi></msub></mrow></math> connecting these vertices, we flip <math id="S4.SS5.SSSx1.p1.m4" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math>.
We perform the same procedure in the opposite direction as well.</p>
</div>
</section>
<section id="S4.SS5.SSSx2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">Subroutine 2: <span class="ltx_text ltx_font_smallcaps">SimpleCoFlip</span>
</h4>

<div id="S4.SS5.SSSx2.p1" class="ltx_para">
<p class="ltx_p">If there is a pair of incompatible edges <math id="S4.SS5.SSSx2.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="S4.SS5.SSSx2.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> that have the same opposite vertices, we flip both of them.</p>
</div>
</section>
<section id="S4.SS5.SSSx3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">Subroutine 3: <span class="ltx_text ltx_font_smallcaps">FlipCompatible</span>
</h4>

<div id="S4.SS5.SSSx3.p1" class="ltx_para">
<p class="ltx_p">Given a compatible edge <math id="S4.SS5.SSSx3.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> and its counterpart <math id="S4.SS5.SSSx3.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup></math>, we check if there is an incompatible edge <math id="S4.SS5.SSSx3.p1.m3" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>2</mn></msubsup></math> that is either connecting <math id="S4.SS5.SSSx3.p1.m4" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math>’s opposite vertices, or is flippable and has the same opposite vertices as <math id="S4.SS5.SSSx3.p1.m5" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math>.
We perform the same check in the opposite direction for <math id="S4.SS5.SSSx3.p1.m6" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup></math>, and if the two checks both pass, we flip <math id="S4.SS5.SSSx3.p1.m7" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> and <math id="S4.SS5.SSSx3.p1.m8" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup></math> (as well as <math id="S4.SS5.SSSx3.p1.m9" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>2</mn></msubsup></math> (resp. <math id="S4.SS5.SSSx3.p1.m10" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup></math>) if it has the same opposite vertices as <math id="S4.SS5.SSSx3.p1.m11" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> (resp. <math id="S4.SS5.SSSx3.p1.m12" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup></math>)).</p>
</div>
</section>
<section id="S4.SS5.SSSx4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">Subroutine 4: <span class="ltx_text ltx_font_smallcaps">FlipFlatPolygon</span>
</h4>

<div id="S4.SS5.SSSx4.p1" class="ltx_para">
<p class="ltx_p">Sometimes, incompatible edges are clustered and form a patch of connected faces with no interior vertex.
In such a case, all the faces in the patch can be flattened to 2D without any distortions, resulting in a pair of compatible 2D polygon boundaries for <math id="S4.SS5.SSSx4.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS5.SSSx4.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>.
Our algorithm tries to triangulate these two polygons in a compatible way.
We use a simple heuristic to achieve this: for each vertex, we check if it is “visible” from each of all the other vertices of the polygon (i.e., the line segment between them is contained within the polygon) for both <math id="S4.SS5.SSSx4.p1.m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS5.SSSx4.p1.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>.
If such a vertex is found, we connect all the other vertices to that found vertex by repeatedly flipping edges.</p>
</div>
<figure id="S4.F4" class="ltx_figure"><img src="x4.png" id="S4.F4.g1" class="ltx_graphics ltx_img_landscape" width="830" height="104" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 4. </span>
An example where <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> is stuck (leftmost) but flipping one compatible edge pair within an incompatible patch (its boundary edges shown in red) leads to a different configuration (middle left) which can be handled by <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span>.
The number above each arrow refers to the used subroutine of <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span>, while the number of incompatible edges in the patch is shown at the bottom of each figure.
</figcaption>
</figure>
<figure id="S4.F5" class="ltx_figure"><img src="x5.png" id="S4.F5.g1" class="ltx_graphics ltx_img_landscape" width="830" height="96" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 5. </span>
Five patterns for merging inconsistently positioned vertices.
Original and inserted vertices are drawn with thick and thin black silhouettes, respectively.
The inserted vertex to be removed after the merge are highlighted by red arrows in each pattern.
</figcaption>
</figure>
</section>
<section id="S4.SS5.SSSx5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">Subroutine 5: <span class="ltx_text ltx_font_smallcaps">DoubleFlipCompatible</span>
</h4>

<div id="S4.SS5.SSSx5.p1" class="ltx_para">
<p class="ltx_p">For a pair of nearby compatible edges <math id="S4.SS5.SSSx5.p1.m1" class="ltx_Math" alttext="(\mathbf{e}_{\mathtt{A}}^{1},\mathbf{e}_{\mathtt{A}}^{2})" display="inline"><mrow><mo stretchy="false">(</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup><mo>,</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow></math> and its counterpart <math id="S4.SS5.SSSx5.p1.m2" class="ltx_Math" alttext="(\mathbf{e}_{\mathtt{B}}^{1},\mathbf{e}_{\mathtt{B}}^{2})" display="inline"><mrow><mo stretchy="false">(</mo><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup><mo>,</mo><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow></math>, we flip all these four edges if the following conditions hold:</p>
</div>
<div id="S4.SS5.SSSx5.p2" class="ltx_para">
<ul id="S4.I1" class="ltx_itemize">
<li id="S4.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I1.i1.p1" class="ltx_para">
<p class="ltx_p"><math id="S4.I1.i1.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> and <math id="S4.I1.i1.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>2</mn></msubsup></math> have the same opposite vertices.</p>
</div>
</li>
<li id="S4.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I1.i2.p1" class="ltx_para">
<p class="ltx_p">There is an incompatible edge <math id="S4.I1.i2.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{3}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>3</mn></msubsup></math> that is connecting the opposite vertices of <math id="S4.I1.i2.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup></math>.</p>
</div>
</li>
<li id="S4.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I1.i3.p1" class="ltx_para">
<p class="ltx_p">There is an incompatible edge <math id="S4.I1.i3.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{3}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>3</mn></msubsup></math> that is connecting the opposite vertices of <math id="S4.I1.i3.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙱</mi><mn>1</mn></msubsup></math>.</p>
</div>
</li>
</ul>
</div>
</section>
</section>
<section id="S4.SS6" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.6. </span>Resolving incompatible patches</h3>

<div id="S4.SS6.p1" class="ltx_para">
<p class="ltx_p">We define a connected set of non-compatible (i.e., reversed or incompatible) faces as an <em class="ltx_emph ltx_font_italic">incompatible patch</em>.
At this point, assuming the input vertex images are reasonably consistent, we expect that the majority of edges have been made compatible and that there are small and sparsely distributed incompatible patches left.
Our strategy then is to examine each of these incompatible patches and try to make them compatible by various means as explained below.</p>
</div>
<div id="S4.SS6.p2" class="ltx_para">
<p class="ltx_p">Note that a pair of incompatible patches in <math id="S4.SS6.p2.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS6.p2.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> can be made correspondent by checking if they consist of the same set of corresponding vertices.
Thus, we extract all the corresponding pairs of incompatible patches and process each of them in order.</p>
</div>
<section id="S4.SS6.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.6.1. </span>Exploring variations by flipping edges within patches</h4>

<div id="S4.SS6.SSS1.p1" class="ltx_para">
<p class="ltx_p">Consider an example incompatible patch shown in Fig. <a href="#S4.F4" title="Figure 4 ‣ Subroutine 4: FlipFlatPolygon ‣ 4.5. FlipToCompatible algorithm ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> at the far left where our <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> algorithm cannot make any progress.
It is, however, still possible to make <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> process this patch if we flip the compatible edge pair highlighted by the red arrows in the figure.
Note that flipping this edge pair does not increase the number of incompatible edges.</p>
</div>
<div id="S4.SS6.SSS1.p2" class="ltx_para">
<p class="ltx_p">Based on this observation, after the termination of <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span>, for each corresponding pair of incompatible patches, and for each corresponding pair of their compatible edges, we check if flipping the edge pair preserves the number of incompatible edges.
If so, we flip the edge pair and run <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> again and see if it makes any progress, and if it does, we go back to the extraction of incompatible patches and repeat.</p>
</div>
</section>
<section id="S4.SS6.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.6.2. </span>Merging inconsistently positioned vertices</h4>

<div id="S4.SS6.SSS2.p1" class="ltx_para">
<p class="ltx_p">After running our edge flipping algorithms as described above, there can still remain a few incompatible patches that cannot be resolved by just flipping edges.
Such incompatible patches are often caused by the input vertex images mapping some vertex pairs close to each other on both <math id="S4.SS6.SSS2.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS6.SSS2.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>, but in slightly inconsistent positions.
Our next strategy then is to merge these vertices so that incompatible edges arising from them will disappear.
We use a pattern-based approach for determining which vertex pair to merge, and we empirically identified five common patterns (Fig. <a href="#S4.F5" title="Figure 5 ‣ Subroutine 4: FlipFlatPolygon ‣ 4.5. FlipToCompatible algorithm ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>).
Note that for pattern 5 we relaxed the notion of face connectedness when extracting incompatible patches so that faces sharing only one vertex can be included in the same patch.
See Appendix <a href="#A1" title="Appendix A Algorithms for merging inconsistently positioned vertices ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">A</span></a> for details about how we handle each pattern.</p>
</div>
</section>
<section id="S4.SS6.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.6.3. </span>Deforming patch boundary</h4>

<figure id="S4.F6" class="ltx_figure"><img src="x6.png" id="S4.F6.g1" class="ltx_graphics ltx_img_landscape" width="830" height="190" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 6. </span>
An example where our vertex merging algorithm cannot merge the purple and brown vertices due to the presence of the pink vertex on <math id="S4.F6.m3" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> (as highlighted by the blue arrow), since the line segment between the green and purple vertices crosses the cyan and orange edges adjacent to the pink vertex.
In such a case, we move the purple vertex on <math id="S4.F6.m4" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> outwards a bit (as highlighted by the yellow arrow) to make the boundary shape of this incompatible patch convex, making its incompatible edge flippable (as highlighted by the red arrow).
</figcaption>
</figure>
<div id="S4.SS6.SSS3.p1" class="ltx_para">
<p class="ltx_p">Our vertex merging algorithm is sometimes unable to merge the intended vertices due to various configurations of vertices neighboring the incompatible patch, as illustrated in Fig. <a href="#S4.F6" title="Figure 6 ‣ 4.6.3. Deforming patch boundary ‣ 4.6. Resolving incompatible patches ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.
In such cases, as a last resort, we try to deform the boundary shape of each incompatible patch so that it becomes convex, which will likely make some non-flippable incompatible edges flippable.
Note that this operation can also fail due to various nearby vertex configurations.
We run <span class="ltx_text ltx_font_smallcaps">FlipToCompatible</span> again if any of the patches could be deformed.</p>
</div>
</section>
</section>
<section id="S4.SS7" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.7. </span>Splitting merged vertices</h3>

<figure id="S4.F7" class="ltx_figure"><img src="x7.png" id="S4.F7.g1" class="ltx_graphics ltx_img_landscape" width="831" height="190" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 7. </span>
The split of a merged vertex.
The pair of edges to be split is indicated by the red arrows, while the displacement vectors for the newly created vertex are indicated by the yellow arrows.
</figcaption>
</figure>
<div id="S4.SS7.p1" class="ltx_para">
<p class="ltx_p">If there are any incompatible edges left at this point, our CIT generation algorithm has failed.
Otherwise, we move to the next step of splitting merged (non-anchor) vertices (Fig. <a href="#S4.F7" title="Figure 7 ‣ 4.7. Splitting merged vertices ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>).
To split a merged vertex, we first need to determine along which pair of edges the split should occur.
We choose such a pair of edges (consistently across <math id="S4.SS7.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS7.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>) in a way that makes the angle between the two edges as close to <math id="S4.SS7.p1.m3" class="ltx_Math" alttext="\pi" display="inline"><mi>π</mi></math> as possible.
The newly created vertex is positioned at a point displaced from the original vertex in the average direction of the two edges and by a small distance (10% of the smallest height of the adjacent faces with the opposite edges being their bases).
Note that the displacements on <math id="S4.SS7.p1.m4" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS7.p1.m5" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> should be opposite in order to maintain consistency.</p>
</div>
</section>
<section id="S4.SS8" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.8. </span>Optimizing connectivity</h3>

<figure id="S4.F8" class="ltx_figure"><img src="x8.png" id="S4.F8.g1" class="ltx_graphics ltx_img_landscape" width="830" height="269" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 8. </span>
An example where flipping edges to minimize the distortion energy can give rise to almost degenerate faces.
A number inside or next to each triangle denotes its area.
</figcaption>
</figure>
<figure id="S4.F9" class="ltx_figure"><img src="x9.png" id="S4.F9.g1" class="ltx_graphics ltx_img_landscape" width="831" height="241" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 9. </span>
The generation of images of <math id="S4.F9.m14" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges on <math id="S4.F9.m15" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s input mesh.
We first detect all the intersections of <math id="S4.F9.m16" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edges against <math id="S4.F9.m17" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges, depicted as red crosses (a).
The numbers in the blue boxes denote the relative arc-length parameter values of the intersections with respect to <math id="S4.F9.m18" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges.
We then reinterpret these intersections as points on <math id="S4.F9.m19" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edges, with their relative arc-length parameter values denoted by the numbers in the white boxes (b).
Finally, we linearly map these points to <math id="S4.F9.m20" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic mesh, obtaining non-geodesic paths, and connect each pair of consecutive path points by a geodesic, obtaining piecewise-geodesic paths on <math id="S4.F9.m21" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s input mesh (c).
The yellow crosses denote intersections of these geodesic pieces and <math id="S4.F9.m22" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original edges, representing the intersections between <math id="S4.F9.m23" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s edges and <math id="S4.F9.m24" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s edges.
We use line thickness to visualize different kinds of edges (<math id="S4.F9.m25" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges, <math id="S4.F9.m26" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original edges, and intrinsic edges), and we use the largest thickness to imply the underlying domain on which the geodesic paths are computed or defined.
</figcaption>
</figure>
<div id="S4.SS8.p1" class="ltx_para">
<p class="ltx_p">Having succeeded in generating a valid CIT, we have a freedom to explore the space of CITs with various connectivities by flipping pairs of corresponding edges.
A tempting strategy then, which we tried initially, is to repeatedly flip each edge pair if doing so results in lower energy, as per the Delaunay flipping algorithm <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>, with an expectation that the final converged configuration will give the smoothest inter-surface map for a given vertex image.
We realized, however, that this strategy has a serious issue: it does not care at all about the generation of almost degenerate faces (Fig. <a href="#S4.F8" title="Figure 8 ‣ 4.8. Optimizing connectivity ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>) which will cause numerical problems both in the computation of energy derivatives and the extraction of the overlay mesh.</p>
</div>
<div id="S4.SS8.p2" class="ltx_para">
<p class="ltx_p">As such, the strategy we adopted is to flip edges such that the smallest angle of corners of triangles on both <math id="S4.SS8.p2.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S4.SS8.p2.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> is maximized.
While leading to a slightly higher energy, this approach generates much better quality triangles which makes our overall pipeline robust, and it tends to make the final edge and face images appear smoother, to our surprise.
An in-depth analysis on the space of CITs by flipping edges is left for future work.</p>
</div>
</section>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5. </span>Obtaining piecewise-linear map</h2>

<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1. </span>Obtaining edge images</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p class="ltx_p">To obtain the piecewise-linear map induced by a CIT in the form of an overlay mesh, we first need to obtain images of <math id="S5.SS1.p1.m1" class="ltx_Math" alttext="E_{\mathtt{A}}" display="inline"><msub><mi>E</mi><mi>𝙰</mi></msub></math> on <math id="S5.SS1.p1.m2" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math> and vice versa, which tell us about where edges of <math id="S5.SS1.p1.m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S5.SS1.p1.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math> intersect.
The process consists of three steps: first, we trace <math id="S5.SS1.p1.m5" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edges <math id="S5.SS1.p1.m6" class="ltx_Math" alttext="\mathbf{E}_{\mathtt{A}}" display="inline"><msub><mi>𝐄</mi><mi>𝙰</mi></msub></math> over <math id="S5.SS1.p1.m7" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s input mesh <math id="S5.SS1.p1.m8" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math> to detect all their intersections with <math id="S5.SS1.p1.m9" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges <math id="S5.SS1.p1.m10" class="ltx_Math" alttext="E_{\mathtt{A}}" display="inline"><msub><mi>E</mi><mi>𝙰</mi></msub></math>, as was done in the original signpost method for visualizing intrinsic edges <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite> (Fig. <a href="#S4.F9" title="Figure 9 ‣ 4.8. Optimizing connectivity ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>a).
Next, we reinterpret the obtained intersections (edge points on <math id="S5.SS1.p1.m11" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math>) as edge points on <math id="S5.SS1.p1.m12" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math>.
This is easily done by calculating the relative arc-length parameter value of each intersection point with respect to the relevant intrinsic edge (Fig. <a href="#S4.F9" title="Figure 9 ‣ 4.8. Optimizing connectivity ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>b).
Note that, by definition, a path corresponding to <math id="S5.SS1.p1.m13" class="ltx_Math" alttext="e_{\mathtt{A}}\in E_{\mathtt{A}}" display="inline"><mrow><msub><mi>e</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>E</mi><mi>𝙰</mi></msub></mrow></math> on <math id="S5.SS1.p1.m14" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> is always a geodesic.
Finally, we linearly map such a path to <math id="S5.SS1.p1.m15" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic mesh <math id="S5.SS1.p1.m16" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>, obtaining a (generally) non-geodesic path on <math id="S5.SS1.p1.m17" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>, and connect its corresponding points on <math id="S5.SS1.p1.m18" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math> by geodesics, obtaining a piecewise-geodesic path on <math id="S5.SS1.p1.m19" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math> (Fig. <a href="#S4.F9" title="Figure 9 ‣ 4.8. Optimizing connectivity ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>c).
The directions and distances for this final geodesic tracing are calculated based on the geometry of <math id="S5.SS1.p1.m20" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>.
Intersections of this piecewise-geodesic path and <math id="S5.SS1.p1.m21" class="ltx_Math" alttext="E_{\mathtt{B}}" display="inline"><msub><mi>E</mi><mi>𝙱</mi></msub></math> are recorded as intersections between <math id="S5.SS1.p1.m22" class="ltx_Math" alttext="e_{\mathtt{A}}" display="inline"><msub><mi>e</mi><mi>𝙰</mi></msub></math> and <math id="S5.SS1.p1.m23" class="ltx_Math" alttext="E_{\mathtt{B}}" display="inline"><msub><mi>E</mi><mi>𝙱</mi></msub></math>.</p>
</div>
<div id="S5.SS1.p2" class="ltx_para">
<p class="ltx_p">We run the same process in the opposite direction to obtain images of <math id="S5.SS1.p2.m1" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original edges on <math id="S5.SS1.p2.m2" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math>.
Note that this second run generates the same set of intersections between <math id="S5.SS1.p2.m3" class="ltx_Math" alttext="E_{\mathtt{A}}" display="inline"><msub><mi>E</mi><mi>𝙰</mi></msub></math> and <math id="S5.SS1.p2.m4" class="ltx_Math" alttext="E_{\mathtt{B}}" display="inline"><msub><mi>E</mi><mi>𝙱</mi></msub></math> up to small numerical errors.</p>
</div>
<figure id="S5.F10" class="ltx_figure"><img src="x10.png" id="S5.F10.g1" class="ltx_graphics ltx_img_landscape" width="830" height="309" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 10. </span>
(Left) Each intrinsic face can be intersected by any number of edges of <math id="S5.F10.m3" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S5.F10.m4" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>, resulting in overlay polygons.
(Right) We enumerate each overlay polygon by using a data structure called <em class="ltx_emph ltx_font_italic">overlay wedge</em> associated with each corner of the overlay polygon.
</figcaption>
</figure>
<figure id="S5.F11" class="ltx_figure"><img src="x11.png" id="S5.F11.g1" class="ltx_graphics ltx_img_landscape" width="831" height="196" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 11. </span>
Overlay wedges generated per overlay vertex (depicted as a black circle at the center in each figure).
(a) For an overlay vertex due to the intersection of two edges, we generate four overlay wedges.
Here, <math id="S5.F11.m14" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edge at index 123 and <math id="S5.F11.m15" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original edge at index 456 are intersected (with their canonical directions depicted as arrows).
We use a common convention that an edge at index <math id="S5.F11.m16" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> has its pair of halfedges at indices <math id="S5.F11.m17" class="ltx_Math" alttext="2n" display="inline"><mrow><mn>2</mn><mo>⁢</mo><mi>n</mi></mrow></math> and <math id="S5.F11.m18" class="ltx_Math" alttext="2n+1" display="inline"><mrow><mrow><mn>2</mn><mo>⁢</mo><mi>n</mi></mrow><mo>+</mo><mn>1</mn></mrow></math>.
(b,c,d) For an overlay vertex of the other types (<math id="S5.F11.m19" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex inserted into <math id="S5.F11.m20" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s face, an anchor vertex where <math id="S5.F11.m21" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex and <math id="S5.F11.m22" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s vertex overlap, and <math id="S5.F11.m23" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s vertex inserted into <math id="S5.F11.m24" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s edge, respectively), we generate overlay wedges according to the number of edges incident to the overlay vertex.
Here, edges of the intrinsic mesh are depicted as thicker lines in various colors.
Note that for (b) and (c), all the wedges have <math id="S5.F11.m25" class="ltx_Math" alttext="\mathtt{t_{IN}}=1" display="inline"><mrow><msub><mi>𝚝</mi><mi>𝙸𝙽</mi></msub><mo>=</mo><mn>1</mn></mrow></math> and <math id="S5.F11.m26" class="ltx_Math" alttext="\mathtt{t_{OUT}}=0" display="inline"><mrow><msub><mi>𝚝</mi><mi>𝙾𝚄𝚃</mi></msub><mo>=</mo><mn>0</mn></mrow></math>.
</figcaption>
</figure>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2. </span>Overlay mesh generation</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p class="ltx_p">Having detected all the intersections between all possible pairs of edges, we are now ready to generate an overlay mesh for each of <math id="S5.SS2.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math> and <math id="S5.SS2.p1.m2" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>.
As the two intrinsic meshes <math id="S5.SS2.p1.m3" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S5.SS2.p1.m4" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math> are compatible, we no longer need to distinguish between them, so we drop the subscript in the following description when referring to the intrinsic mesh and its elements.
Our goal is to enumerate all the overlay polygons in each intrinsic face <math id="S5.SS2.p1.m5" class="ltx_Math" alttext="\mathbf{f}\in\mathbf{F}" display="inline"><mrow><mi>𝐟</mi><mo>∈</mo><mi>𝐅</mi></mrow></math> which can be intersected by any number of <math id="S5.SS2.p1.m6" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original edges and <math id="S5.SS2.p1.m7" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original edges (Fig. <a href="#S5.F10" title="Figure 10 ‣ 5.1. Obtaining edge images ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a> left).
We achieve this using a data structure called an <em class="ltx_emph ltx_font_italic">overlay wedge</em> which is generated for each corner of an overlay polygon and encodes information about which halfedge to switch to when going around the overlay polygon (Fig. <a href="#S5.F10" title="Figure 10 ‣ 5.1. Obtaining edge images ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a> right), as explained below.</p>
</div>
<div id="S5.SS2.p2" class="ltx_para">
<p class="ltx_p">We call each vertex in an overlay mesh an <em class="ltx_emph ltx_font_italic">overlay vertex</em> which can come from either</p>
<ol id="S5.I1" class="ltx_enumerate">
<li id="S5.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(1)</span> 
<div id="S5.I1.i1.p1" class="ltx_para">
<p class="ltx_p">an intersection between edges (which can come from either <math id="S5.I1.i1.p1.m1" class="ltx_Math" alttext="E_{\mathtt{A}}" display="inline"><msub><mi>E</mi><mi>𝙰</mi></msub></math>, <math id="S5.I1.i1.p1.m2" class="ltx_Math" alttext="E_{\mathtt{B}}" display="inline"><msub><mi>E</mi><mi>𝙱</mi></msub></math>, or <math id="S5.I1.i1.p1.m3" class="ltx_Math" alttext="\mathbf{E}" display="inline"><mi>𝐄</mi></math>),</p>
</div>
</li>
<li id="S5.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(2)</span> 
<div id="S5.I1.i2.p1" class="ltx_para">
<p class="ltx_p"><math id="S5.I1.i2.p1.m1" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original vertex <math id="S5.I1.i2.p1.m2" class="ltx_Math" alttext="V_{\mathtt{A}}" display="inline"><msub><mi>V</mi><mi>𝙰</mi></msub></math>, or</p>
</div>
</li>
<li id="S5.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(3)</span> 
<div id="S5.I1.i3.p1" class="ltx_para">
<p class="ltx_p"><math id="S5.I1.i3.p1.m1" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original vertex <math id="S5.I1.i3.p1.m2" class="ltx_Math" alttext="V_{\mathtt{B}}" display="inline"><msub><mi>V</mi><mi>𝙱</mi></msub></math>.</p>
</div>
</li>
</ol>
<p class="ltx_p">For the first case, we generate a quadruplet of overlay wedges for each intersection (Fig. <a href="#S5.F11" title="Figure 11 ‣ 5.1. Obtaining edge images ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a>a).
An overlay wedge <math id="S5.SS2.p2.m1" class="ltx_Math" alttext="\mathtt{w}" display="inline"><mi>𝚠</mi></math> stores a reference to the halfedge <math id="S5.SS2.p2.m2" class="ltx_Math" alttext="\mathtt{h_{IN}}" display="inline"><msub><mi>𝚑</mi><mi>𝙸𝙽</mi></msub></math> which comes into the corner when viewed from inside its associated overlay polygon (assuming the counterclockwise ordering), along with the relative arc-length parameter value <math id="S5.SS2.p2.m3" class="ltx_Math" alttext="\mathtt{t_{IN}}" display="inline"><msub><mi>𝚝</mi><mi>𝙸𝙽</mi></msub></math> representing the position of the intersection on <math id="S5.SS2.p2.m4" class="ltx_Math" alttext="\mathtt{h_{IN}}" display="inline"><msub><mi>𝚑</mi><mi>𝙸𝙽</mi></msub></math>.
Note that <math id="S5.SS2.p2.m5" class="ltx_Math" alttext="\mathtt{h_{IN}}" display="inline"><msub><mi>𝚑</mi><mi>𝙸𝙽</mi></msub></math> can refer to either the intrinsic mesh’s halfedge <math id="S5.SS2.p2.m6" class="ltx_Math" alttext="\mathbf{h}" display="inline"><mi>𝐡</mi></math>, <math id="S5.SS2.p2.m7" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s original halfedge <math id="S5.SS2.p2.m8" class="ltx_Math" alttext="h_{\mathtt{A}}" display="inline"><msub><mi>h</mi><mi>𝙰</mi></msub></math>, or <math id="S5.SS2.p2.m9" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s original halfedge <math id="S5.SS2.p2.m10" class="ltx_Math" alttext="h_{\mathtt{B}}" display="inline"><msub><mi>h</mi><mi>𝙱</mi></msub></math>.
Likewise, <math id="S5.SS2.p2.m11" class="ltx_Math" alttext="\mathtt{w}" display="inline"><mi>𝚠</mi></math> also stores a reference to the outgoing halfedge <math id="S5.SS2.p2.m12" class="ltx_Math" alttext="\mathtt{h_{OUT}}" display="inline"><msub><mi>𝚑</mi><mi>𝙾𝚄𝚃</mi></msub></math> and its associated parameter value <math id="S5.SS2.p2.m13" class="ltx_Math" alttext="\mathtt{t_{OUT}}" display="inline"><msub><mi>𝚝</mi><mi>𝙾𝚄𝚃</mi></msub></math>.</p>
</div>
<div id="S5.SS2.p3" class="ltx_para">
<p class="ltx_p">For the other two cases, we generate a number of overlay wedges according to the number of edges incident to the overlay vertex (Fig. <a href="#S5.F11" title="Figure 11 ‣ 5.1. Obtaining edge images ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a>b-d).
To do so, we first need to determine the correct ordering of halfedges incident to the overlay vertex originating from different sources (<math id="S5.SS2.p3.m1" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math>, <math id="S5.SS2.p3.m2" class="ltx_Math" alttext="M_{\mathtt{B}}" display="inline"><msub><mi>M</mi><mi>𝙱</mi></msub></math>, or <math id="S5.SS2.p3.m3" class="ltx_Math" alttext="\mathbf{M}" display="inline"><mi>𝐌</mi></math>), which is possible thanks to the signpost data structure storing directions of intrinsic edges relative to the canonical tangent spaces defined on vertices, edges, and faces of the input mesh <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>.</p>
</div>
<div id="S5.SS2.p4" class="ltx_para">
<p class="ltx_p">Having processed all the overlay vertices and generated all the overlay wedges, we group them by their <math id="S5.SS2.p4.m1" class="ltx_Math" alttext="\mathtt{h_{IN}}" display="inline"><msub><mi>𝚑</mi><mi>𝙸𝙽</mi></msub></math> fields, and for each group, we sort them by their <math id="S5.SS2.p4.m2" class="ltx_Math" alttext="\mathtt{t_{IN}}" display="inline"><msub><mi>𝚝</mi><mi>𝙸𝙽</mi></msub></math> values.
This allows us to find, given an overlay wedge <math id="S5.SS2.p4.m3" class="ltx_Math" alttext="\mathtt{w}" display="inline"><mi>𝚠</mi></math>, its “next” overlay wedge in the overlay polygon by the following procedure:</p>
<ol id="S5.I2" class="ltx_enumerate">
<li id="S5.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(1)</span> 
<div id="S5.I2.i1.p1" class="ltx_para">
<p class="ltx_p">obtain the sorted list of wedges associated with <math id="S5.I2.i1.p1.m1" class="ltx_Math" alttext="\mathtt{w.h_{OUT}}" display="inline"><mrow><mi>𝚠</mi><mo lspace="0em" rspace="0.167em">.</mo><msub><mi>𝚑</mi><mi>𝙾𝚄𝚃</mi></msub></mrow></math>, and</p>
</div>
</li>
<li id="S5.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">(2)</span> 
<div id="S5.I2.i2.p1" class="ltx_para">
<p class="ltx_p">scan the list in the ascending order and return the first item whose <math id="S5.I2.i2.p1.m1" class="ltx_Math" alttext="\mathtt{t_{IN}}" display="inline"><msub><mi>𝚝</mi><mi>𝙸𝙽</mi></msub></math> value is greater than <math id="S5.I2.i2.p1.m2" class="ltx_Math" alttext="\mathtt{w.t_{OUT}}" display="inline"><mrow><mi>𝚠</mi><mo lspace="0em" rspace="0.167em">.</mo><msub><mi>𝚝</mi><mi>𝙾𝚄𝚃</mi></msub></mrow></math>.</p>
</div>
</li>
</ol>
<p class="ltx_p">This way, we can find cycles of overlay wedges and thus generate overlay polygons.</p>
</div>
<div id="S5.SS2.p5" class="ltx_para">
<p class="ltx_p">Also, because each overlay wedge stores references to halfedges of the input meshes, we can transfer the texture coordinate data present in the original meshes (which are typically stored per halfedge) to the overlay meshes.
This allows us to transfer a texture image from one model to the other while preserving all the seams, as demonstrated in Fig. <a href="#S0.F1" title="Figure 1 ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>c.</p>
</div>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6. </span>Optimization</h2>

<figure id="S6.F12" class="ltx_figure"><img src="x12.png" id="S6.F12.g1" class="ltx_graphics ltx_img_landscape" width="831" height="273" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 12. </span>

Flattening of <math id="S6.F12.m6" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>’s support patch (left) and <math id="S6.F12.m7" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math>’s support patch (right) for the computation of the energy derivative.

Note that the orange vertex which originates in <math id="S6.F12.m8" class="ltx_Math" alttext="V_{\mathtt{B}}" display="inline"><msub><mi>V</mi><mi>𝙱</mi></msub></math> is inserted into <math id="S6.F12.m9" class="ltx_Math" alttext="e_{\mathtt{A}}\in E_{\mathtt{A}}" display="inline"><mrow><msub><mi>e</mi><mi>𝙰</mi></msub><mo>∈</mo><msub><mi>E</mi><mi>𝙰</mi></msub></mrow></math>, and we need to include its adjacent face not overlapping with <math id="S6.F12.m10" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> in the patch because it is used as the tangent space for that edge point.
</figcaption>
</figure>
<section id="S6.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.1. </span>Computing energy &amp; derivatives</h3>

<div id="S6.SS1.p1" class="ltx_para">
<p class="ltx_p">Given a CIT, computing its distortion energy (measured using the symmetric Dirichlet as was done in the previous work <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>) is simple if it were not for its derivative computation: the intrinsic edge lengths already define the 2D shape of each intrinsic face, so we can trivially compute the energy using these 2D shapes:</p>
<table id="S6.E1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_left"><span class="ltx_tag ltx_tag_equation ltx_align_left">(1)</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S6.E1.m1" class="ltx_Math" alttext="\mathcal{E}=\sum_{\mathbf{f}\in\mathbf{F}}\|\mathbf{J}(\mathbf{f})\|_{\mathrm{%
F}}^{2}\ Area(\mathbf{f}_{\mathtt{B}})+\|\mathbf{J}(\mathbf{f})^{-1}\|_{%
\mathrm{F}}^{2}\ Area(\mathbf{f}_{\mathtt{A}})" display="block"><mrow><mi class="ltx_font_mathcaligraphic">ℰ</mi><mo rspace="0.111em">=</mo><mrow><mrow><munder><mo movablelimits="false" rspace="0em">∑</mo><mrow><mi>𝐟</mi><mo>∈</mo><mi>𝐅</mi></mrow></munder><mrow><msubsup><mrow><mo stretchy="false">‖</mo><mrow><mi>𝐉</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐟</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">‖</mo></mrow><mi mathvariant="normal">F</mi><mn>2</mn></msubsup><mo>⁢</mo><mi>A</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><msubsup><mrow><mo stretchy="false">‖</mo><mrow><mi>𝐉</mi><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mi>𝐟</mi><mo stretchy="false">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><mo stretchy="false">‖</mo></mrow><mi mathvariant="normal">F</mi><mn>2</mn></msubsup><mo>⁢</mo><mi>A</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math id="S6.SS1.p1.m1" class="ltx_Math" alttext="\mathbf{J}(\mathbf{f})=\mathbf{D}(\mathbf{f}_{\mathtt{B}})\mathbf{D}(\mathbf{f%
}_{\mathtt{A}})^{-1}\in\mathbb{R}^{2\times 2}" display="inline"><mrow><mrow><mi>𝐉</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>𝐟</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>𝐃</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>𝐃</mi><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>2</mn><mo lspace="0.222em" rspace="0.222em">×</mo><mn>2</mn></mrow></msup></mrow></math> is a map Jacobian deforming <math id="S6.SS1.p1.m2" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> into <math id="S6.SS1.p1.m3" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}" display="inline"><msub><mi>𝐟</mi><mi>𝙱</mi></msub></math> in an arbitrary 2D embedding, <math id="S6.SS1.p1.m4" class="ltx_Math" alttext="\mathbf{D}(\mathbf{f}_{\mathtt{A}})=[\mathbf{p}_{2}-\mathbf{p}_{1},\mathbf{p}_%
{3}-\mathbf{p}_{1}]\in\mathbb{R}^{2\times 2}" display="inline"><mrow><mrow><mi>𝐃</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">[</mo><mrow><msub><mi>𝐩</mi><mn>2</mn></msub><mo>−</mo><msub><mi>𝐩</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>𝐩</mi><mn>3</mn></msub><mo>−</mo><msub><mi>𝐩</mi><mn>1</mn></msub></mrow><mo stretchy="false">]</mo></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>2</mn><mo lspace="0.222em" rspace="0.222em">×</mo><mn>2</mn></mrow></msup></mrow></math>, and <math id="S6.SS1.p1.m5" class="ltx_Math" alttext="\mathbf{p}_{1},\mathbf{p}_{2},\mathbf{p}_{3}\in\mathbb{R}^{2}" display="inline"><mrow><mrow><msub><mi>𝐩</mi><mn>1</mn></msub><mo>,</mo><msub><mi>𝐩</mi><mn>2</mn></msub><mo>,</mo><msub><mi>𝐩</mi><mn>3</mn></msub></mrow><mo>∈</mo><msup><mi>ℝ</mi><mn>2</mn></msup></mrow></math> are the embedded 2D coordinates of <math id="S6.SS1.p1.m6" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>’s three corners (<math id="S6.SS1.p1.m7" class="ltx_Math" alttext="\mathbf{D}(\mathbf{f}_{\mathtt{B}})\in\mathbb{R}^{2\times 2}" display="inline"><mrow><mrow><mi>𝐃</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>2</mn><mo lspace="0.222em" rspace="0.222em">×</mo><mn>2</mn></mrow></msup></mrow></math> is defined analogously).
We use this lightweight method to compute the energy during the line search as described in Sec. <a href="#S6.SS2" title="6.2. Overall scheme ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6.2</span></a>.</p>
</div>
<div id="S6.SS1.p2" class="ltx_para">
<p class="ltx_p">To compute the derivative, however, we need to express the energy as a function of the input vertex images <math id="S6.SS1.p2.m1" class="ltx_Math" alttext="\mathcal{E}(\phi_{\mathtt{A}\rightarrow\mathtt{B}},\phi_{\mathtt{B}\rightarrow%
\mathtt{A}})" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">ℰ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>,</mo><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mrow></math>, which boils down to expressing those embedded 2D coordinates of intrinsic faces’ corners (i.e., <math id="S6.SS1.p2.m2" class="ltx_Math" alttext="\mathbf{p}_{1},\mathbf{p}_{2}" display="inline"><mrow><msub><mi>𝐩</mi><mn>1</mn></msub><mo>,</mo><msub><mi>𝐩</mi><mn>2</mn></msub></mrow></math> and <math id="S6.SS1.p2.m3" class="ltx_Math" alttext="\mathbf{p}_{3}" display="inline"><msub><mi>𝐩</mi><mn>3</mn></msub></math> introduced above) as linear combinations of 2D coordinates of <math id="S6.SS1.p2.m4" class="ltx_Math" alttext="V_{\mathtt{A}}" display="inline"><msub><mi>V</mi><mi>𝙰</mi></msub></math> or <math id="S6.SS1.p2.m5" class="ltx_Math" alttext="V_{\mathtt{B}}" display="inline"><msub><mi>V</mi><mi>𝙱</mi></msub></math> locally embedded in 2D.
For example, suppose one corner of <math id="S6.SS1.p2.m6" class="ltx_Math" alttext="\mathbf{f}\in\mathbf{F}" display="inline"><mrow><mi>𝐟</mi><mo>∈</mo><mi>𝐅</mi></mrow></math> originates in <math id="S6.SS1.p2.m7" class="ltx_Math" alttext="v_{\mathtt{B}}\in V_{\mathtt{B}}" display="inline"><mrow><msub><mi>v</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>V</mi><mi>𝙱</mi></msub></mrow></math> and is mapped to a face point on <math id="S6.SS1.p2.m8" class="ltx_Math" alttext="M_{\mathtt{A}}" display="inline"><msub><mi>M</mi><mi>𝙰</mi></msub></math> as <math id="S6.SS1.p2.m9" class="ltx_Math" alttext="\phi_{\mathtt{B}\rightarrow\mathtt{A}}(v_{\mathtt{B}})=(f_{\mathtt{A}},(%
\lambda_{1},\lambda_{2},\lambda_{3}))" display="inline"><mrow><mrow><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>𝙰</mi></msub><mo>,</mo><mrow><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></math> where <math id="S6.SS1.p2.m10" class="ltx_Math" alttext="\lambda_{1}&gt;0" display="inline"><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>&gt;</mo><mn>0</mn></mrow></math>, <math id="S6.SS1.p2.m11" class="ltx_Math" alttext="\lambda_{2}&gt;0" display="inline"><mrow><msub><mi>λ</mi><mn>2</mn></msub><mo>&gt;</mo><mn>0</mn></mrow></math> and <math id="S6.SS1.p2.m12" class="ltx_Math" alttext="\lambda_{3}=1-\lambda_{1}-\lambda_{2}&gt;0" display="inline"><mrow><msub><mi>λ</mi><mn>3</mn></msub><mo>=</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub></mrow><mo>&gt;</mo><mn>0</mn></mrow></math>.
Then, we need to express the 2D coordinate of the corresponding corner of <math id="S6.SS1.p2.m13" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> as a function of <math id="S6.SS1.p2.m14" class="ltx_Math" alttext="\lambda_{1}" display="inline"><msub><mi>λ</mi><mn>1</mn></msub></math> and <math id="S6.SS1.p2.m15" class="ltx_Math" alttext="\lambda_{2}" display="inline"><msub><mi>λ</mi><mn>2</mn></msub></math>:</p>
<table id="S6.E2" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_left"><span class="ltx_tag ltx_tag_equation ltx_align_left">(2)</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S6.E2.m1" class="ltx_Math" alttext="\mathbf{p}(\lambda_{1},\lambda_{2})=\lambda_{1}\mathbf{q}_{1}+\lambda_{2}%
\mathbf{q}_{2}+(1-\lambda_{1}-\lambda_{2})\mathbf{q}_{3}" display="block"><mrow><mrow><mi>𝐩</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>⁢</mo><msub><mi>𝐪</mi><mn>1</mn></msub></mrow><mo>+</mo><mrow><msub><mi>λ</mi><mn>2</mn></msub><mo>⁢</mo><msub><mi>𝐪</mi><mn>2</mn></msub></mrow><mo>+</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msub><mi>𝐪</mi><mn>3</mn></msub></mrow></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math id="S6.SS1.p2.m16" class="ltx_Math" alttext="\mathbf{q}_{1},\mathbf{q}_{2}" display="inline"><mrow><msub><mi>𝐪</mi><mn>1</mn></msub><mo>,</mo><msub><mi>𝐪</mi><mn>2</mn></msub></mrow></math> and <math id="S6.SS1.p2.m17" class="ltx_Math" alttext="\mathbf{q}_{3}" display="inline"><msub><mi>𝐪</mi><mn>3</mn></msub></math> are the 2D coordinates of <math id="S6.SS1.p2.m18" class="ltx_Math" alttext="f_{\mathtt{A}}" display="inline"><msub><mi>f</mi><mi>𝙰</mi></msub></math> embedded in 2D locally.
Note that this local embedding (or flattening) must be consistent (i.e., in a common coordinate frame) among all the original faces <math id="S6.SS1.p2.m19" class="ltx_Math" alttext="\{f_{\mathtt{A}}\}\subset F_{\mathtt{A}}" display="inline"><mrow><mrow><mo stretchy="false">{</mo><msub><mi>f</mi><mi>𝙰</mi></msub><mo stretchy="false">}</mo></mrow><mo>⊂</mo><msub><mi>F</mi><mi>𝙰</mi></msub></mrow></math> that support <math id="S6.SS1.p2.m20" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> (we call this face set <math id="S6.SS1.p2.m21" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>’s <em class="ltx_emph ltx_font_italic">support patch</em>, see Fig. <a href="#S6.F12" title="Figure 12 ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a> left).
This is always possible without introducing any distortions thanks to the construction of intrinsic triangulations guaranteeing nonexistence of original vertices inside any of intrinsic faces <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>.</p>
</div>
<div id="S6.SS1.p3" class="ltx_para">
<p class="ltx_p">Note that when <math id="S6.SS1.p3.m1" class="ltx_Math" alttext="\phi_{\mathtt{B}\rightarrow\mathtt{A}}(v_{\mathtt{B}})" display="inline"><mrow><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> is an edge point, we use one of the edge’s two adjacent faces (determined by the edge’s canonical orientation) as the tangent space and reinterpret the edge point as a face point in that face.
For this reason, <math id="S6.SS1.p3.m2" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>’s support patch must include such an adjacent face even if it does not overlap with <math id="S6.SS1.p3.m3" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> (see the bottom right triangle of <math id="S6.SS1.p3.m4" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>’s support patch in Fig. <a href="#S6.F12" title="Figure 12 ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a> left).</p>
</div>
<div id="S6.SS1.p4" class="ltx_para">
<p class="ltx_p">We perform the same procedure for <math id="S6.SS1.p4.m1" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{B}}\in\mathbf{F}_{\mathtt{B}}" display="inline"><mrow><msub><mi>𝐟</mi><mi>𝙱</mi></msub><mo>∈</mo><msub><mi>𝐅</mi><mi>𝙱</mi></msub></mrow></math> corresponding to <math id="S6.SS1.p4.m2" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math> (Fig. <a href="#S6.F12" title="Figure 12 ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a> right), and derive the energy expression as a function of all the barycentric coordinates of the input vertex images involved in this intrinsic face.
In the absence of anchor vertices, each corner of an intrinsic face corresponds to an inserted vertex in one model and to an original vertex in the other model, so each corner has two degrees of freedom, and each intrinsic face has six degrees of freedom.
The existence of an anchor vertex decreases the degrees of freedom by two.</p>
</div>
<div id="S6.SS1.p5" class="ltx_para">
<p class="ltx_p">We use automatic differentiation to compute a local gradient vector <math id="S6.SS1.p5.m1" class="ltx_Math" alttext="\mathbf{g}_{\mathbf{f}}\in\mathbb{R}^{6}" display="inline"><mrow><msub><mi>𝐠</mi><mi>𝐟</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mn>6</mn></msup></mrow></math> and a Hessian matrix <math id="S6.SS1.p5.m2" class="ltx_Math" alttext="\mathbf{H}_{\mathbf{f}}\in\mathbb{R}^{6\times 6}" display="inline"><mrow><msub><mi>𝐇</mi><mi>𝐟</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mrow><mn>6</mn><mo lspace="0.222em" rspace="0.222em">×</mo><mn>6</mn></mrow></msup></mrow></math> per intrinsic face <math id="S6.SS1.p5.m3" class="ltx_Math" alttext="\mathbf{f}\in\mathbf{F}" display="inline"><mrow><mi>𝐟</mi><mo>∈</mo><mi>𝐅</mi></mrow></math>.
These local quantities are accumulated in a global gradient vector <math id="S6.SS1.p5.m4" class="ltx_Math" alttext="\mathbf{g}\in\mathbb{R}^{n}" display="inline"><mrow><mi>𝐠</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>n</mi></msup></mrow></math> and a Hessian matrix <math id="S6.SS1.p5.m5" class="ltx_Math" alttext="\mathbf{H}\in\mathbb{R}^{n\times n}" display="inline"><mrow><mi>𝐇</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mi>n</mi><mo lspace="0.222em" rspace="0.222em">×</mo><mi>n</mi></mrow></msup></mrow></math> where <math id="S6.SS1.p5.m6" class="ltx_Math" alttext="n=2(|V_{\mathtt{A}}|+|V_{\mathtt{B}}|)" display="inline"><mrow><mi>n</mi><mo>=</mo><mrow><mn>2</mn><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">|</mo><msub><mi>V</mi><mi>𝙰</mi></msub><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><msub><mi>V</mi><mi>𝙱</mi></msub><mo stretchy="false">|</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math> in the absence of anchor vertices.
As in the previous work <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>, we make the global Hessian <math id="S6.SS1.p5.m7" class="ltx_Math" alttext="\mathbf{H}" display="inline"><mi>𝐇</mi></math> positive definite by clamping negative eigenvalues of the local Hessian <math id="S6.SS1.p5.m8" class="ltx_Math" alttext="\mathbf{H}_{\mathbf{f}}" display="inline"><msub><mi>𝐇</mi><mi>𝐟</mi></msub></math> before accumulating.</p>
</div>
</section>
<section id="S6.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.2. </span>Overall scheme</h3>

<div id="S6.SS2.p1" class="ltx_para">
<p class="ltx_p">We basically adopt the same second-order optimization scheme as in the previous work <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>:</p>
<ul id="S6.I1" class="ltx_itemize">
<li id="S6.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S6.I1.i1.p1" class="ltx_para">
<p class="ltx_p">We temporally smooth the gradient as <math id="S6.I1.i1.p1.m1" class="ltx_Math" alttext="\bar{\mathbf{g}}=\sum_{i=0}^{5}2^{-i}\mathbf{g}_{i}" display="inline"><mrow><mover accent="true"><mi>𝐠</mi><mo>¯</mo></mover><mo rspace="0.111em">=</mo><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>5</mn></msubsup><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>i</mi></mrow></msup><mo>⁢</mo><msub><mi>𝐠</mi><mi>i</mi></msub></mrow></mrow></mrow></math> where <math id="S6.I1.i1.p1.m2" class="ltx_Math" alttext="\mathbf{g}_{i}" display="inline"><msub><mi>𝐠</mi><mi>i</mi></msub></math> is the gradient of the configuration <math id="S6.I1.i1.p1.m3" class="ltx_Math" alttext="i" display="inline"><mi>i</mi></math> steps previous to the current one. Temporally smoothed Hessian <math id="S6.I1.i1.p1.m4" class="ltx_Math" alttext="\bar{\mathbf{H}}" display="inline"><mover accent="true"><mi>𝐇</mi><mo>¯</mo></mover></math> is obtained analogously.</p>
</div>
</li>
<li id="S6.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S6.I1.i2.p1" class="ltx_para">
<p class="ltx_p">We compute the descent direction <math id="S6.I1.i2.p1.m1" class="ltx_Math" alttext="\mathbf{d}\in\mathbb{R}^{n}" display="inline"><mrow><mi>𝐝</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>n</mi></msup></mrow></math> by solving</p>
<table id="S6.E3" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td rowspan="1" class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_left"><span class="ltx_tag ltx_tag_equation ltx_align_left">(3)</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S6.E3.m1" class="ltx_Math" alttext="(\bar{\mathbf{H}}+w_{\mathrm{L}}(\mathbf{S}\mathbf{L})^{\top}\mathbf{M}\mathbf%
{S}\mathbf{L})\mathbf{d}=-\bar{\mathbf{g}}" display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mover accent="true"><mi>𝐇</mi><mo>¯</mo></mover><mo>+</mo><mrow><msub><mi>w</mi><mi mathvariant="normal">L</mi></msub><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mi>𝐒𝐋</mi><mo stretchy="false">)</mo></mrow><mo>⊤</mo></msup><mo>⁢</mo><mi>𝐌𝐒𝐋</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>𝐝</mi></mrow><mo>=</mo><mrow><mo>−</mo><mover accent="true"><mi>𝐠</mi><mo>¯</mo></mover></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">where <math id="S6.I1.i2.p1.m2" class="ltx_Math" alttext="w_{\mathrm{L}}" display="inline"><msub><mi>w</mi><mi mathvariant="normal">L</mi></msub></math> is a weight for the Laplacian preconditioning, <math id="S6.I1.i2.p1.m3" class="ltx_Math" alttext="\mathbf{L}" display="inline"><mi>𝐋</mi></math> is the connection Laplacian, <math id="S6.I1.i2.p1.m4" class="ltx_Math" alttext="\mathbf{S}" display="inline"><mi>𝐒</mi></math> is a block-diagonal matrix responsible for making the tangent vector magnitudes comparable, and <math id="S6.I1.i2.p1.m5" class="ltx_Math" alttext="\mathbf{M}" display="inline"><mi>𝐌</mi></math> is the diagonal mass matrix.</p>
</div>
</li>
<li id="S6.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S6.I1.i3.p1" class="ltx_para">
<p class="ltx_p">We perform a line search by evaluating the energy at <math id="S6.I1.i3.p1.m1" class="ltx_Math" alttext="\mathbf{x}+s\mathbf{d}" display="inline"><mrow><mi>𝐱</mi><mo>+</mo><mrow><mi>s</mi><mo>⁢</mo><mi>𝐝</mi></mrow></mrow></math> where <math id="S6.I1.i3.p1.m2" class="ltx_Math" alttext="\mathbf{x}\in\mathbb{R}^{n}" display="inline"><mrow><mi>𝐱</mi><mo>∈</mo><msup><mi>ℝ</mi><mi>n</mi></msup></mrow></math> is the current configuration (i.e., barycentric coordinates in the vertex images) and <math id="S6.I1.i3.p1.m3" class="ltx_Math" alttext="s&gt;0" display="inline"><mrow><mi>s</mi><mo>&gt;</mo><mn>0</mn></mrow></math> is the step size.</p>
</div>
</li>
</ul>
<p class="ltx_p">Because our variables are barycentric coordinates, all of the above are realized through the concept of tangent vector transport; please refer to Section 1 of the supplementary material of <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> for more details.</p>
</div>
<div id="S6.SS2.p2" class="ltx_para">
<p class="ltx_p">As opposed to the previous method which determined the feasibility of a given step size by the emergence of flipped triangles, we deem a given step size to be feasible if our CIT generation algorithm succeeds with it.
When determining the maximum step size <math id="S6.SS2.p2.m1" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> for the line search, we initialize it based on the current descent direction vector (we set <math id="S6.SS2.p2.m2" class="ltx_Math" alttext="s_{\mathrm{max}}=0.01/d_{\mathrm{max}}" display="inline"><mrow><msub><mi>s</mi><mi>max</mi></msub><mo>=</mo><mrow><mn>0.01</mn><mo>/</mo><msub><mi>d</mi><mi>max</mi></msub></mrow></mrow></math> where <math id="S6.SS2.p2.m3" class="ltx_Math" alttext="d_{\mathrm{max}}" display="inline"><msub><mi>d</mi><mi>max</mi></msub></math> is the largest length of the 2D descent direction vectors after being scaled from the barycentric coordinates to the comparable lengths).
If this initial value turns out to be feasible, we enter the <em class="ltx_emph ltx_font_italic">upward</em> mode where we multiply <math id="S6.SS2.p2.m4" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> by 1.2 and see if the increased <math id="S6.SS2.p2.m5" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> is infeasible.
Otherwise, we enter the <em class="ltx_emph ltx_font_italic">downward</em> mode where we divide <math id="S6.SS2.p2.m6" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> by 1.2 and see if the decreased <math id="S6.SS2.p2.m7" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> is feasible.
With <math id="S6.SS2.p2.m8" class="ltx_Math" alttext="s_{\mathrm{max}}" display="inline"><msub><mi>s</mi><mi>max</mi></msub></math> determined, we look for the optimal step size satisfying the Armijo condition as was done in the previous method.</p>
</div>
</section>
<section id="S6.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">6.3. </span>Dealing with local minima</h3>

<div id="S6.SS3.p1" class="ltx_para">
<p class="ltx_p">Our method lacks one important feature that existed in the previous method <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>: the metric regularization.
It was used in the initial few hundred steps to smooth out excess distortions in the input maps, and we believe this contributed greatly to the robustness of their optimization algorithm.
In our case, unfortunately, we do not have anything that has the same effect as the metric regularization, and thus our optimization algorithm can easily get trapped by local minima, as discussed in Sec. <a href="#S7.SS1" title="7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7.1</span></a>.</p>
</div>
<div id="S6.SS3.p2" class="ltx_para">
<p class="ltx_p">We found empirically that when we get stuck in a local minimum, it is often possible to make (sometimes great) progress if we switch to the first-order optimization scheme.
The reason we speculate is that the energy landscape can sometimes get very non-smooth with steep peaks and dents, making the quadratic approximation of the second-order optimization scheme a poor fit.
As such, we devised the following simple workaround:
we start with the second-order mode, and when we get stuck in a local minimum, we switch to the first-order mode and keep moving until we get stuck again in another local minimum, then we switch back to the second-order mode and repeat, until we get stuck in both schemes.</p>
</div>
</section>
</section>
<section id="S7" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7. </span>Results</h2>

<section id="S7.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Implementation and setup.</h5>

<div id="S7.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">We implemented our algorithm using geometry-central <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib46" title="Geometry-central" class="ltx_ref">2019a</a>)</cite> that includes the reference implementation of the signpost data structure <cite class="ltx_cite ltx_citemacro_citep">(Sharp<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib3" title="Navigating intrinsic triangulations" class="ltx_ref">2019b</a>)</cite>.
We used an unsupported module in Eigen <cite class="ltx_cite ltx_citemacro_citep">(Guennebaud<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib45" title="Eigen v3" class="ltx_ref">2010</a>)</cite> for automatic differentiation.
We ran all the experiments on Ryzen 9 3900X with 32GB of RAM running Ubuntu 20.04.1 LTS, and we always used a single thread during the optimization.
We normalized the given input triangle meshes such that their total surface areas equal to one, meaning that the best attainable energy is 4.0.
As opposed to the previous work, we did not impose any limit on the number of the optimization steps and let the algorithm run until it gets stuck (we stopped the optimization when the energy decrease fell below <math id="S7.SS0.SSS0.Px1.p1.m1" class="ltx_Math" alttext="10^{-5}" display="inline"><msup><mn>10</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></math>).</p>
</div>
</section>
<section id="S7.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">7.1. </span>Initial map generation</h3>

<div id="S7.SS1.p1" class="ltx_para">
<p class="ltx_p">To create the initial vertex images, we used the reference implementation of HOT <cite class="ltx_cite ltx_citemacro_citep">(Aigerman and Lipman, <a href="#bib.bib31" title="Hyperbolic orbifold tutte embeddings" class="ltx_ref">2016</a>)</cite> and our own implementation of Seamless Surface Mappings (SSM) <cite class="ltx_cite ltx_citemacro_citep">(Aigerman<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib21" title="Seamless surface mappings" class="ltx_ref">2015</a>)</cite> (which we will release at <a href="https://github.com/kenshi84/seamlesssurfmap" title="" class="ltx_ref ltx_url ltx_font_typewriter">https://github.com/kenshi84/seamlesssurfmap</a>) for genus 0 cases and high genus cases, respectively.
Because the success of our CIT generation/optimization algorithm depends heavily on the quality of the initial map, we allowed ourselves to use as many landmarks as necessary to produce good quality maps.</p>
</div>
<div id="S7.SS1.p2" class="ltx_para">
<p class="ltx_p">While theoretical analysis of exact conditions for the success of our CIT generation/optimization algorithm is left for future work, empirically we found some tips on how to place landmarks in an effective way.
First, common to HOT and SSM, the mapping distortion tends to concentrate near landmarks; in particular, a landmark, when mapped to the other surface, may appear as if it was “pinched” in a certain direction (Fig. <a href="#S7.F13" title="Figure 13 ‣ 7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a>a).
For a vertex image where this pinching effect is very strong, our CIT generation tends to fail.
In such cases, we slightly shift those problematic landmarks toward the opposite of the pinched direction (Fig. <a href="#S7.F13" title="Figure 13 ‣ 7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a>b).</p>
</div>
<div id="S7.SS1.p3" class="ltx_para">
<p class="ltx_p">Second, when mapping an elongated part, if we placed just one landmark at the tip of the part, its nearby vertices, when mapped to the other surface, may often get severely concentrated or dispersed (Fig. <a href="#S7.F13" title="Figure 13 ‣ 7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a>c).
Even though our CIT generation algorithm often succeeds with such a vertex image, our CIT optimization algorithm often gets stuck in a local minimum, unable to distribute those vertices evenly.
To avoid this, we add a few more landmarks near the tip of the part so that the vertex distribution becomes more even (Fig. <a href="#S7.F13" title="Figure 13 ‣ 7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a>d).
See the supplemental material for our choices of landmarks.</p>
</div>
<figure id="S7.F13" class="ltx_figure"><img src="x13.png" id="S7.F13.g1" class="ltx_graphics ltx_img_landscape" width="399" height="160" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 13. </span>

Tips on placing landmarks.
“B on A” visualizes the vertex image <math id="S7.F13.m3" class="ltx_Math" alttext="\phi_{\mathtt{B}\rightarrow\mathtt{A}}" display="inline"><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub></math> as a mesh <math id="S7.F13.m4" class="ltx_Math" alttext="(\phi_{\mathtt{B}\rightarrow\mathtt{A}}(V_{\mathtt{B}}),E_{\mathtt{B}},F_{%
\mathtt{B}})" display="inline"><mrow><mo stretchy="false">(</mo><mrow><msub><mi>ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><msub><mi>E</mi><mi>𝙱</mi></msub><mo>,</mo><msub><mi>F</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></math>, and vice versa.
Mapping distortion concentrated near a landmark may appear as if the landmark was “pinched” in a certain direction (a), and this may cause our CIT generation algorithm to fail.
This can be remedied by shifting the landmark toward the opposite of the pinched direction (b).
Placing just one landmark at the tip of an elongated part may lead to too uneven distribution of mapped vertices (c), which may cause our CIT optimization algorithm to get stuck in a local minimum.
To avoid this, we place a few more landmarks (d).

</figcaption>
</figure>
</section>
<section id="S7.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">7.2. </span>Comparison to Schmidt et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>
</h3>

<div id="S7.SS2.p1" class="ltx_para">
<p class="ltx_p">We ran our method on the dataset released by Schmidt et al. <cite class="ltx_cite ltx_citemacro_citeyearpar">(<a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> and compared the final distortion energy (see Fig. <a href="#S7.F14" title="Figure 14 ‣ 7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">14</span></a> for the final optimized maps).
As shown in Table <a href="#S7.T1" title="Table 1 ‣ 7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>, our optimized distortion energy is below that of the previous method <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> on all but the <span class="ltx_text ltx_font_smallcaps">Ant-Octopus</span> and <span class="ltx_text ltx_font_smallcaps">Pig-Armadillo</span> cases.
We believe the lower values of our energy are due to the fact that Schmidt et al. terminated optimization after a fixed number of steps, whereas we let the optimizer run until it can make no more progress.
The two unsuccessful cases are of extremely non-isometric shape pairs, and our algorithm quickly gets trapped by local minima.</p>
</div>
<figure id="S7.F14" class="ltx_figure"><img src="x14.png" id="S7.F14.g1" class="ltx_graphics ltx_img_landscape" width="831" height="173" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 14. </span>
Optimization results on the dataset of <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>.
</figcaption>
</figure>
<figure id="S7.T1" class="ltx_table">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_table">Table 1. </span>
The result statistics.
<span class="ltx_text ltx_font_bold">#F</span> refers to the total number of triangles of the input triangle mesh pair, <span class="ltx_text ltx_font_bold">#N</span> refers to the number of optimization steps taken, <span class="ltx_text ltx_font_bold">T</span> refers to the total time taken for the optimization, and <span class="ltx_text ltx_font_bold">E</span> refers to the energy of the optimized map.
The energy of the map generated by the previous method is shown in the rightmost column.
</figcaption>
<table class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_column ltx_th_row ltx_border_tt">Case name</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_tt"><span class="ltx_text ltx_font_bold">#F</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_tt"><span class="ltx_text ltx_font_bold">#N</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><span class="ltx_text ltx_font_bold">T</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><span class="ltx_text ltx_font_bold">E</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_tt"><cite class="ltx_cite ltx_citemacro_citep"><span class="ltx_text" style="font-size:70%;">(</span>Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span><span class="ltx_text" style="font-size:70%;">, </span><a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a><span class="ltx_text" style="font-size:70%;">)</span></cite></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_t"><span class="ltx_text ltx_font_smallcaps">Planes</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_t">25k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_t">231</th>
<td class="ltx_td ltx_align_center ltx_border_t">15.0h</td>
<td class="ltx_td ltx_align_center ltx_border_t">4.35</td>
<td class="ltx_td ltx_align_center ltx_border_t">4.69</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Cow-Horse</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">10k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">225</th>
<td class="ltx_td ltx_align_center">3.8h</td>
<td class="ltx_td ltx_align_center">4.73</td>
<td class="ltx_td ltx_align_center">5.28</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Hands</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">32k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">366</th>
<td class="ltx_td ltx_align_center">37.6h</td>
<td class="ltx_td ltx_align_center">4.35</td>
<td class="ltx_td ltx_align_center">4.83</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Genus3</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">3k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">440</th>
<td class="ltx_td ltx_align_center">2.9h</td>
<td class="ltx_td ltx_align_center">4.21</td>
<td class="ltx_td ltx_align_center">4.36</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Genus5</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">8k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">767</th>
<td class="ltx_td ltx_align_center">15.0h</td>
<td class="ltx_td ltx_align_center">4.49</td>
<td class="ltx_td ltx_align_center">4.74</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Pretzel</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">12k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">532</th>
<td class="ltx_td ltx_align_center">11.2h</td>
<td class="ltx_td ltx_align_center">5.25</td>
<td class="ltx_td ltx_align_center">5.53</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Donut-Duck</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">24k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">585</th>
<td class="ltx_td ltx_align_center">78.9h</td>
<td class="ltx_td ltx_align_center">4.68</td>
<td class="ltx_td ltx_align_center">4.77</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Vase</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">10k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">542</th>
<td class="ltx_td ltx_align_center">9.1h</td>
<td class="ltx_td ltx_align_center">4.60</td>
<td class="ltx_td ltx_align_center">5.00</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row"><span class="ltx_text ltx_font_smallcaps">Ant-Octopus</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">8k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row">4</th>
<td class="ltx_td ltx_align_center">1m</td>
<td class="ltx_td ltx_align_center">98.3</td>
<td class="ltx_td ltx_align_center">16.2</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_bb"><span class="ltx_text ltx_font_smallcaps">Pig-Armadillo</span></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_bb">22k</th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_bb">370</th>
<td class="ltx_td ltx_align_center ltx_border_bb">19.9h</td>
<td class="ltx_td ltx_align_center ltx_border_bb">8.10</td>
<td class="ltx_td ltx_align_center ltx_border_bb">7.78</td>
</tr>
</tbody>
</table>
</figure>
</section>
<section id="S7.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">7.3. </span>Evaluation with Princeton Segmentation Dataset</h3>

<div id="S7.SS3.p1" class="ltx_para">
<p class="ltx_p">Our method is inherently empirical, hence it is difficult to theoretically analyze how well it works in practice.
To evaluate practical utility of our method, we ran our CIT optimization on models included in the Princeton 3D Mesh Segmentation Dataset <cite class="ltx_cite ltx_citemacro_citep">(Chen<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib4" title="A benchmark for 3D mesh segmentation" class="ltx_ref">2009</a>)</cite>.
The dataset consists of 19 categories, each containing 20 triangle meshes.
We randomly chose 5 pairs in each category, totaling <math id="S7.SS3.p1.m1" class="ltx_Math" alttext="19\times 5=95" display="inline"><mrow><mrow><mn>19</mn><mo lspace="0.222em" rspace="0.222em">×</mo><mn>5</mn></mrow><mo>=</mo><mn>95</mn></mrow></math> pairs.
To make our experiment more meaningful, we created some rules to filter out some clearly inappropriate pairs as well as extremely poor quality geometries.
In some categories, we also introduced some additional sub-categories within which we formed pairs randomly, so that the problem setting becomes more relevant.
See the supplemental material for how we selected the pairs.
Note also that we often applied moderate degree of mesh cleaning such as remeshing and reduction to eliminate erroneous configurations such as edges of almost zero dihedral angles.</p>
</div>
<div id="S7.SS3.p2" class="ltx_para">
<p class="ltx_p">Fig. <a href="#S7.F15" title="Figure 15 ‣ 7.3. Evaluation with Princeton Segmentation Dataset ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">15</span></a> shows a sample of our optimized surface mapping from each category, indicating that our method indeed produces good quality maps.
See the supplemental material for the detailed statistics as well as all the images of the mappings of all pairs.</p>
</div>
<div id="S7.SS3.p3" class="ltx_para">
<p class="ltx_p">Of the 95 cases, 7 cases (41-59, 50-46, 53-54, 55-51, 124-139, 146-156, 399-385), all genus 0, could not be handled by HOT (due to flipped triangles detected during its LBFGS optimization), no matter how we chose the landmarks.
Out of the remaining 88 cases, we had 7 cases (62-72, 128-136, 129-126, 130-134, 152-149, 220-201, 386-397) where our CIT generation algorithm failed due to too extreme distortion in the mapping generated by HOT (Fig. <a href="#S7.F16" title="Figure 16 ‣ 7.3. Evaluation with Princeton Segmentation Dataset ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">16</span></a>).
For the two cases 62-72 and 386-397, the shapes are widely different near the tail region, while for the two cases 152-149 and 220-201, the overall shapes are very different.
For the three cases 128-136, 129-126 and 130-134, the very thin and long tentacles of the octopuses are arranged in some inconsistent manner.</p>
</div>
<figure id="S7.F15" class="ltx_figure"><img src="x15.png" id="S7.F15.g1" class="ltx_graphics ltx_img_landscape" width="831" height="427" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 15. </span>
Sample optimized maps from our experiment on the Princeton Segmentation Dataset.
</figcaption>
</figure>
<figure id="S7.F16" class="ltx_figure"><img src="x16.png" id="S7.F16.g1" class="ltx_graphics ltx_img_landscape" width="415" height="104" alt="Refer to caption">
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 16. </span>
7 cases where our CIT generation algorithm failed..
</figcaption>
</figure>
<div id="S7.SS3.p4" class="ltx_para">
<p class="ltx_p">Apart from these rather extreme cases, our CIT generation and optimization algorithm succeeded on 81 models out of 88, giving us success rate of 92%.</p>
</div>
</section>
</section>
<section id="S8" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">8. </span>Conclusion and future work</h2>

<div id="S8.p1" class="ltx_para">
<p class="ltx_p">In this work, we showed that it is possible to consistently define, given vertex images as input, images of edges and faces of one model onto the other model using Compatible Intrinsic Triangulations instead of constant-curvature metrics <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite>.
We demonstrated that our CIT generation algorithm is robust enough to be used within a second-order global optimization framework.</p>
</div>
<div id="S8.p2" class="ltx_para">
<p class="ltx_p">There are, however, a number of issues in our current approach.
First, there are no theoretical grounds supporting our CIT generation algorithm which we devised only through empirical observations.
A thorough analysis of our problem setting is essential and can be a key to improving the robustness when handling extremely distorted vertex images.</p>
</div>
<div id="S8.p3" class="ltx_para">
<p class="ltx_p">One possible idea for improving our algorithm’s success rate is to introduce additional vertices which are both inserted on <math id="S8.p3.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and <math id="S8.p3.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>, much like the Steiner vertices for 2D triangulation.
We have not tried it yet as it seemed to complicate our optimization framework due to the number of variables changing at every step, especially when considering the treatment of the temporal smoothing operator.</p>
</div>
<div id="S8.p4" class="ltx_para">
<p class="ltx_p">Another possible way of improvement would be to devise a mechanism that has the same effect as the metric regularization feature in the previous work <cite class="ltx_cite ltx_citemacro_citep">(Schmidt<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib1" title="Distortion-minimizing injective maps between surfaces" class="ltx_ref">2019</a>, <a href="#bib.bib2" title="Inter-surface maps via constant-curvature metrics" class="ltx_ref">2020</a>)</cite> which we believe will make our optimization algorithm significantly more robust.</p>
</div>
<div id="S8.p5" class="ltx_para">
<p class="ltx_p">Finally, an interesting future direction would be to combine our method with recent techniques for computing bijective maps between coarse and fine meshes such as <cite class="ltx_cite ltx_citemacro_citep">(Jiang<span class="ltx_text ltx_bib_etal"> et al.</span>, <a href="#bib.bib47" title="Bijective projection in a shell" class="ltx_ref">2020</a>)</cite>, in order to enable a multi-resolution framework for the inter-surface mapping problem.
This will benefit from the simplicity of our approach, requiring only vertex images as input, in contrast to the previous method which requires valid constant-curvature metrics in addition to vertex images.</p>
</div>
<div class="ltx_acknowledgements">
<h6 class="ltx_title ltx_title_acknowledgements">Acknowledgements.</h6>
We thank the anonymous reviewers for their constructive feedback.
We also thank Ryoich Ando for generously offering us an access to his powerful computing environment which was essential for conducting our experiment.

</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul id="bib.L1" class="ltx_biblist">
<li id="bib.bib27" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Aigerman, S. Z. Kovalsky, and Y. Lipman (2017)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Spherical orbifold tutte embeddings</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">36</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib20" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Aigerman and Y. Lipman (2015)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Orbifold tutte embeddings</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">34</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib31" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Aigerman and Y. Lipman (2016)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Hyperbolic orbifold tutte embeddings</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">35</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>,
<a href="#S3.p1" title="3. Overview ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§3</span></a>,
<a href="#S7.SS1.p1" title="7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7.1</span></a>.
</span>
</li>
<li id="bib.bib19" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Aigerman, R. Poranne, and Y. Lipman (2014)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Lifted bijections for low distortion surface mappings</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">33</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib21" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Aigerman, R. Poranne, and Y. Lipman (2015)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Seamless surface mappings</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">34</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>,
<a href="#S7.SS1.p1" title="7.1. Initial map generation ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7.1</span></a>.
</span>
</li>
<li id="bib.bib41" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">M. Alexa, D. Cohen-Or, and D. Levin (2000)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">As-rigid-as-possible shape interpolation</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Proceedings of the 27th Annual Conference on Computer Graphics and Interactive Techniques</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_series">SIGGRAPH ’00</span>, <span class="ltx_text ltx_bib_pages"> pp. 157–164</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px2.p1" title="Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib29" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">M. Alexa (2000)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Merging polyhedral shapes with scattered features</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">The Visual Computer</span> <span class="ltx_text ltx_bib_volume">16</span> (<span class="ltx_text ltx_bib_number">1</span>), <span class="ltx_text ltx_bib_pages"> pp. 26–37</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib30" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">A. Asirvatham, E. Praun, and H. Hoppe (2005)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Consistent spherical parameterization</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Computational Science – ICCS 2005</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_pages"> pp. 265–272</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib28" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">A. Baden, K. Crane, and M. Kazhdan (2018)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Möbius registration</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">37</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 211–220</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib42" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">W. V. Baxter III, P. Barla, and K. Anjyo (2009)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Compatible embedding for 2d shape animation</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Trans. Vis. Comput. Graph.</span> <span class="ltx_text ltx_bib_volume">15</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 867–879</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px2.p1" title="Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib12" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">S. Bouaziz, A. Tagliasacchi, and M. Pauly (2013)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Sparse iterative closest point</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">32</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 113–123</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib4" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">X. Chen, A. Golovinskiy, and T. Funkhouser (2009)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">A benchmark for 3D mesh segmentation</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">28</span> (<span class="ltx_text ltx_bib_number">3</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S7.SS3.p1" title="7.3. Evaluation with Princeton Segmentation Dataset ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7.3</span></a>.
</span>
</li>
<li id="bib.bib37" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">A. F. El Ouafdi, H. El Houari, and D. Ziou (2021)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Adaptive estimation of hodge star operator on simplicial surfaces</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">The Visual Computer</span> <span class="ltx_text ltx_bib_volume">37</span> (<span class="ltx_text ltx_bib_number">6</span>), <span class="ltx_text ltx_bib_pages"> pp. 1433–1445</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib5" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">D. Ezuz, B. Heeren, O. Azencot, M. Rumpf, and M. Ben-Chen (2019a)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Elastic correspondence between triangle meshes</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">38</span> (<span class="ltx_text ltx_bib_number">2</span>), <span class="ltx_text ltx_bib_pages"> pp. 121–134</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib6" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">D. Ezuz, J. Solomon, and M. Ben-Chen (2019b)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Reversible harmonic maps between discrete surfaces</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">38</span> (<span class="ltx_text ltx_bib_number">2</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib36" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">M. Fumero, M. Möller, and E. Rodolà (2020)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Nonlinear spectral geometry processing via the tv transform</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib45" class="ltx_bibitem ltx_bib_misc">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">G. Guennebaud, B. Jacob, <span class="ltx_text ltx_bib_etal">et al.</span> (2010)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Eigen v3</span>.
</span>
<span class="ltx_bibblock">Note: <span class="ltx_text ltx_bib_note"><span class="ltx_ref ltx_nolink ltx_url ltx_font_typewriter ltx_ref_self">https://eigen.tuxfamily.org/dox/unsupported/group__AutoDiff__Module.html</span></span>
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S7.SS0.SSS0.Px1.p1" title="Implementation and setup. ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7</span></a>.
</span>
</li>
<li id="bib.bib11" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Q. Huang, B. Adams, M. Wicke, and L. J. Guibas (2008)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Non-rigid registration under isometric deformations</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">27</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 1449–1457</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib47" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Z. Jiang, T. Schneider, D. Zorin, and D. Panozzo (2020)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Bijective projection in a shell</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S8.p5" title="8. Conclusion and future work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§8</span></a>.
</span>
</li>
<li id="bib.bib22" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">T. Kanai, H. Suzuki, and F. Kimura (1997)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">3D geometric metamorphosis based on harmonic map</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Proceedings The Fifth Pacific Conference on Computer Graphics and Applications</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_pages"> pp. 97–104</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib23" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">V. G. Kim, Y. Lipman, and T. Funkhouser (2011)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Blended intrinsic maps</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">30</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib34" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">V. Kraevoy and A. Sheffer (2004)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Cross-parameterization and compatible remeshing of 3d models</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">23</span> (<span class="ltx_text ltx_bib_number">3</span>), <span class="ltx_text ltx_bib_pages"> pp. 861–869</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i4.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4th item</span></a>,
<a href="#S2.p2" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib24" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Y. Lipman and T. Funkhouser (2009)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Möbius voting for surface correspondence</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">28</span> (<span class="ltx_text ltx_bib_number">3</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib25" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Litke, M. Droske, M. Rumpf, and P. Schröder (2005)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">An Image Processing Approach to Surface Matching</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Eurographics Symposium on Geometry Processing 2005</span>,
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>,
<a href="#S2.p2" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib43" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Z. Liu, L. Zhou, H. Leung, and H. P. H. Shum (2018)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">High-quality compatible triangulations and their application in interactive animation</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Computers &amp; Graphics</span> <span class="ltx_text ltx_bib_volume">76</span>, <span class="ltx_text ltx_bib_pages"> pp. 60–72</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px2.p1" title="Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib10" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">M. Mandad, D. Cohen-Steiner, L. Kobbelt, P. Alliez, and M. Desbrun (2017)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Variance-minimizing transport plans for inter-surface mapping</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">36</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib8" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">M. Ovsjanikov, M. Ben-Chen, J. Solomon, A. Butscher, and L. Guibas (2012)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Functional maps: a flexible representation of maps between shapes</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">31</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib7" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">D. Panozzo, I. Baran, O. Diamanti, and O. Sorkine-Hornung (2013)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Weighted averages on surfaces</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">32</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib35" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">E. Praun, W. Sweldens, and P. Schröder (2001)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Consistent mesh parameterizations</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Proceedings of the 28th Annual Conference on Computer Graphics and Interactive Techniques</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_series">SIGGRAPH ’01</span>, <span class="ltx_text ltx_bib_pages"> pp. 179–184</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i4.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4th item</span></a>.
</span>
</li>
<li id="bib.bib1" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">P. Schmidt, J. Born, M. Campen, and L. Kobbelt (2019)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Distortion-minimizing injective maps between surfaces</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">38</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>,
<a href="#S2.p2" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>,
<a href="#S6.SS1.p1" title="6.1. Computing energy &amp; derivatives ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.1</span></a>,
<a href="#S6.SS1.p5" title="6.1. Computing energy &amp; derivatives ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.1</span></a>,
<a href="#S6.SS2.p1" title="6.2. Overall scheme ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.2</span></a>,
<a href="#S8.p4" title="8. Conclusion and future work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§8</span></a>.
</span>
</li>
<li id="bib.bib2" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">P. Schmidt, M. Campen, J. Born, and L. Kobbelt (2020)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Inter-surface maps via constant-curvature metrics</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.p2" title="1. Introduction ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§1</span></a>,
<a href="#S1.p3" title="1. Introduction ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§1</span></a>,
<a href="#S1.p4" title="1. Introduction ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§1</span></a>,
<a href="#S2.p3" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>,
<a href="#S3.p3" title="3. Overview ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§3</span></a>,
<a href="#S6.SS1.p1" title="6.1. Computing energy &amp; derivatives ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.1</span></a>,
<a href="#S6.SS1.p5" title="6.1. Computing energy &amp; derivatives ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.1</span></a>,
<a href="#S6.SS2.p1" title="6.2. Overall scheme ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.2</span></a>,
<a href="#S6.SS3.p1" title="6.3. Dealing with local minima ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.3</span></a>,
<a href="#S7.F14" title="In 7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">Figure 14</span></a>,
<a href="#S7.SS2" title="7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7.2</span></a>,
<a href="#S7.SS2.p1" title="7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7.2</span></a>,
<a href="#S7.T1" title="In 7.2. Comparison to Schmidt et al. (2020) ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">Table 1</span></a>,
<a href="#S8.p1" title="8. Conclusion and future work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§8</span></a>,
<a href="#S8.p4" title="8. Conclusion and future work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§8</span></a>.
</span>
</li>
<li id="bib.bib33" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">J. Schreiner, A. Asirvatham, E. Praun, and H. Hoppe (2004)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Inter-surface mapping</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">23</span> (<span class="ltx_text ltx_bib_number">3</span>), <span class="ltx_text ltx_bib_pages"> pp. 870–877</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i4.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4th item</span></a>,
<a href="#S2.p2" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib13" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">A. Sharf, M. Blumenkrants, A. Shamir, and D. Cohen-Or (2006)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">SnapPaste: an interactive technique for easy mesh composition</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">The Visual Computer</span> <span class="ltx_text ltx_bib_volume">22</span> (<span class="ltx_text ltx_bib_number">9</span>), <span class="ltx_text ltx_bib_pages"> pp. 835–844</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib46" class="ltx_bibitem ltx_bib_misc">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Sharp, K. Crane, <span class="ltx_text ltx_bib_etal">et al.</span> (2019a)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Geometry-central</span>.
</span>
<span class="ltx_bibblock">Note: <span class="ltx_text ltx_bib_note"><span class="ltx_ref ltx_nolink ltx_url ltx_font_typewriter ltx_ref_self">https://www.geometry-central.net</span></span>
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S7.SS0.SSS0.Px1.p1" title="Implementation and setup. ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7</span></a>.
</span>
</li>
<li id="bib.bib38" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Sharp and K. Crane (2020a)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">A laplacian for nonmanifold triangle meshes</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 69–80</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib39" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Sharp and K. Crane (2020b)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">You can find geodesic paths in triangle meshes by just flipping edges</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">6</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib3" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">N. Sharp, Y. Soliman, and K. Crane (2019b)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Navigating intrinsic triangulations</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">38</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S1.p3" title="1. Introduction ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§1</span></a>,
<a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>,
<a href="#S2.p3" title="2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>,
<a href="#S4.SS2.p3" title="4.2. Compatible edges &amp; faces ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§4.2</span></a>,
<a href="#S4.SS3.p1" title="4.3. Delaunay flipping ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§4.3</span></a>,
<a href="#S4.SS8.p1" title="4.8. Optimizing connectivity ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§4.8</span></a>,
<a href="#S5.SS1.p1" title="5.1. Obtaining edge images ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§5.1</span></a>,
<a href="#S5.SS2.p3" title="5.2. Overlay mesh generation ‣ 5. Obtaining piecewise-linear map ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§5.2</span></a>,
<a href="#S6.SS1.p2" title="6.1. Computing energy &amp; derivatives ‣ 6. Optimization ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§6.1</span></a>,
<a href="#S7.SS0.SSS0.Px1.p1" title="Implementation and setup. ‣ 7. Results ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§7</span></a>.
</span>
</li>
<li id="bib.bib32" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">R. Shi, W. Zeng, Z. Su, J. Jiang, H. Damasio, Z. Lu, Y. Wang, S. Yau, and X. Gu (2017)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Hyperbolic harmonic mapping for surface registration</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Trans. Pattern Anal. Mach. Intell.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">05</span>), <span class="ltx_text ltx_bib_pages"> pp. 965–980</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib9" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">J. Solomon, A. Nguyen, A. Butscher, M. Ben-Chen, and L. Guibas (2012)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Soft maps between surfaces</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Comput. Graph. Forum</span> <span class="ltx_text ltx_bib_volume">31</span> (<span class="ltx_text ltx_bib_number">5</span>), <span class="ltx_text ltx_bib_pages"> pp. 1617–1626</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i2.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2nd item</span></a>.
</span>
</li>
<li id="bib.bib44" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">V. Surazhsky and C. Gotsman (2004)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">High quality compatible triangulations</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Eng. with Comput.</span> <span class="ltx_text ltx_bib_volume">20</span> (<span class="ltx_text ltx_bib_number">2</span>), <span class="ltx_text ltx_bib_pages"> pp. 147–156</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px2.p1" title="Compatible triangulations for 2D animation ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib14" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">G. K.L. Tam, Z. Cheng, Y. Lai, F. C. Langbein, Y. Liu, D. Marshall, R. R. Martin, X. Sun, and P. L. Rosin (2013)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Registration of 3d point clouds and meshes: a survey from rigid to nonrigid</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Trans. Vis. Comput. Graph.</span> <span class="ltx_text ltx_bib_volume">19</span> (<span class="ltx_text ltx_bib_number">7</span>), <span class="ltx_text ltx_bib_pages"> pp. 1199–1217</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib40" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">J. Tao, J. Zhang, B. Deng, Z. Fang, Y. Peng, and Y. He (2021)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Parallel and scalable heat methods for geodesic distance computation</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Trans. Pattern Anal. Mach. Intell.</span> <span class="ltx_text ltx_bib_volume">43</span> (<span class="ltx_text ltx_bib_number">2</span>), <span class="ltx_text ltx_bib_pages"> pp. 579–594</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.SS0.SSS0.Px1.p1" title="Intrinsic triangulations ‣ 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">§2</span></a>.
</span>
</li>
<li id="bib.bib26" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">J. Tierny, J. Daniels, L. G. Nonato, V. Pascucci, and C. T. Silva (2011)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Inspired quadrangulation</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">Computer-Aided Design</span> <span class="ltx_text ltx_bib_volume">43</span> (<span class="ltx_text ltx_bib_number">11</span>), <span class="ltx_text ltx_bib_pages"> pp. 1516–1526</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I2.i1.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1st item</span></a>.
</span>
</li>
<li id="bib.bib15" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">H. Wu, C. Pan, Q. Yang, and S. Ma (2007)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Consistent correspondence between arbitrary manifold surfaces</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">International Conference on Computer Vision</span>,
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib16" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Y. Yang, X. Fu, S. Chai, S. Xiao, and L. Liu (2019)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Volume-enhanced compatible remeshing of 3d models</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">IEEE Trans. Vis. Comput. Graph.</span> <span class="ltx_text ltx_bib_volume">25</span> (<span class="ltx_text ltx_bib_number">10</span>), <span class="ltx_text ltx_bib_pages"> pp. 2999–3010</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib17" class="ltx_bibitem ltx_bib_article">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">Y. Yang, W. Zhang, Y. Liu, L. Liu, and X. Fu (2020)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Error-bounded compatible remeshing</span>.
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_journal">ACM Trans. Graph.</span> <span class="ltx_text ltx_bib_volume">39</span> (<span class="ltx_text ltx_bib_number">4</span>).
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
<li id="bib.bib18" class="ltx_bibitem ltx_bib_inproceedings">
<span class="ltx_tag ltx_bib_author-year ltx_role_refnum ltx_tag_bibitem">L. Zhang, L. Liu, Z. Ji, and G. Wang (2006)</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_title">Manifold parameterization</span>.
</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_bib_inbook">Advances in Computer Graphics</span>,
</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_bib_pages"> pp. 160–171</span>.
</span>
<span class="ltx_bibblock ltx_bib_cited">Cited by: <a href="#S2.I1.i3.p1" title="In 2. Related work ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3rd item</span></a>.
</span>
</li>
</ul>
</section>
<section id="A1" class="ltx_appendix">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix A </span>Algorithms for merging inconsistently positioned vertices</h2>

<div id="A1.p1" class="ltx_para">
<p class="ltx_p">We match the given incompatible patch pair against each of the five patterns shown in Fig. <a href="#S4.F5" title="Figure 5 ‣ Subroutine 4: FlipFlatPolygon ‣ 4.5. FlipToCompatible algorithm ‣ 4. CIT generation ‣ Compatible Intrinsic Triangulations" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>.
Each pattern analyzes the given patch pair and returns an edge pair (one on <math id="A1.p1.m1" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math> and the other on <math id="A1.p1.m2" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>) that meets certain conditions defined for that pattern.
We then collapse such a returned edge pair if it is collapsible.
We give up on a patch pair if none of the patterns return an edge pair for collapse.</p>
</div>
<div id="A1.p2" class="ltx_para">
<p class="ltx_p">Below, we use <math id="A1.p2.m1" class="ltx_Math" alttext="\bm{\phi}_{\mathtt{A}\rightarrow\mathtt{B}}" display="inline"><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub></math> and <math id="A1.p2.m2" class="ltx_Math" alttext="\bm{\phi}_{\mathtt{B}\rightarrow\mathtt{A}}" display="inline"><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub></math> to refer to the available correspondences between <math id="A1.p2.m3" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{A}}" display="inline"><msub><mi>𝐌</mi><mi>𝙰</mi></msub></math>’s elements and <math id="A1.p2.m4" class="ltx_Math" alttext="\mathbf{M}_{\mathtt{B}}" display="inline"><msub><mi>𝐌</mi><mi>𝙱</mi></msub></math>’s elements; e.g., <math id="A1.p2.m5" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{B}}=\bm{\phi}_{\mathtt{A}\rightarrow\mathtt{B}}(\mathbf{v}%
_{\mathtt{A}})" display="inline"><mrow><msub><mi>𝐯</mi><mi>𝙱</mi></msub><mo>=</mo><mrow><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐯</mi><mi>𝙰</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math> refers to <math id="A1.p2.m6" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic vertex corresponding to <math id="A1.p2.m7" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic vertex (which is always available), and <math id="A1.p2.m8" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}=\bm{\phi}_{\mathtt{B}\rightarrow\mathtt{A}}(\mathbf{e}%
_{\mathtt{B}})" display="inline"><mrow><msub><mi>𝐞</mi><mi>𝙰</mi></msub><mo>=</mo><mrow><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐞</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math> refers to <math id="A1.p2.m9" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s intrinsic edge corresponding to <math id="A1.p2.m10" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s intrinsic edge, assuming that the edge is compatible.</p>
</div>
<section id="A1.SS0.SSS0.Px1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Pattern 1</h5>

<div id="A1.SS0.SSS0.Px1.p1" class="ltx_para">
<p class="ltx_p">We first check if the patch contains no interior vertices.
We then look for vertices whose interior angle (i.e., the sum of corner angles of adjacent faces in the patch) is larger than <math id="A1.SS0.SSS0.Px1.p1.m1" class="ltx_Math" alttext="\pi" display="inline"><mi>π</mi></math>.
If <math id="A1.SS0.SSS0.Px1.p1.m2" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s patch and <math id="A1.SS0.SSS0.Px1.p1.m3" class="ltx_Math" alttext="\mathtt{B}" display="inline"><mi>𝙱</mi></math>’s patch contain one such vertex each (referred to as <math id="A1.SS0.SSS0.Px1.p1.m4" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{A}}" display="inline"><msub><mi>𝐯</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px1.p1.m5" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{B}}" display="inline"><msub><mi>𝐯</mi><mi>𝙱</mi></msub></math>, respectively), and if there exists an edge at <math id="A1.SS0.SSS0.Px1.p1.m6" class="ltx_Math" alttext="\mathtt{A}" display="inline"><mi>𝙰</mi></math>’s patch boundary connecting <math id="A1.SS0.SSS0.Px1.p1.m7" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{A}}" display="inline"><msub><mi>𝐯</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px1.p1.m8" class="ltx_Math" alttext="\bm{\phi}_{\mathtt{B}\rightarrow\mathtt{A}}(\mathbf{v}_{\mathtt{B}})" display="inline"><mrow><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙱</mi><mo stretchy="false">→</mo><mi>𝙰</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>𝐯</mi><mi>𝙱</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math>, we return that edge.</p>
</div>
</section>
<section id="A1.SS0.SSS0.Px2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Pattern 2</h5>

<div id="A1.SS0.SSS0.Px2.p1" class="ltx_para">
<p class="ltx_p">We first check if the patch contains just one interior vertex <math id="A1.SS0.SSS0.Px2.p1.m1" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{A}}" display="inline"><msub><mi>𝐯</mi><mi>𝙰</mi></msub></math> and just one reversed face <math id="A1.SS0.SSS0.Px2.p1.m2" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>.
We also check if <math id="A1.SS0.SSS0.Px2.p1.m3" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{A}}" display="inline"><msub><mi>𝐯</mi><mi>𝙰</mi></msub></math> is adjacent to <math id="A1.SS0.SSS0.Px2.p1.m4" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>.
Then we examine the two edges <math id="A1.SS0.SSS0.Px2.p1.m5" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> and <math id="A1.SS0.SSS0.Px2.p1.m6" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup></math> adjacent to both <math id="A1.SS0.SSS0.Px2.p1.m7" class="ltx_Math" alttext="\mathbf{v}_{\mathtt{A}}" display="inline"><msub><mi>𝐯</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px2.p1.m8" class="ltx_Math" alttext="\mathbf{f}_{\mathtt{A}}" display="inline"><msub><mi>𝐟</mi><mi>𝙰</mi></msub></math>.
We return <math id="A1.SS0.SSS0.Px2.p1.m9" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{1}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup></math> if <math id="A1.SS0.SSS0.Px2.p1.m10" class="ltx_Math" alttext="|\mathbf{e}_{\mathtt{A}}^{1}|+|\bm{\phi}_{\mathtt{A}\rightarrow\mathtt{B}}(%
\mathbf{e}_{\mathtt{A}}^{1})|&lt;|\mathbf{e}_{\mathtt{A}}^{2}|+|\bm{\phi}_{%
\mathtt{A}\rightarrow\mathtt{B}}(\mathbf{e}_{\mathtt{A}}^{2})|" display="inline"><mrow><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>1</mn></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></mrow><mo>&lt;</mo><mrow><mrow><mo stretchy="false">|</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><msub><mi class="ltx_mathvariant_bold-italic" mathvariant="bold-italic">ϕ</mi><mrow><mi>𝙰</mi><mo stretchy="false">→</mo><mi>𝙱</mi></mrow></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></mrow></mrow></math>, otherwise <math id="A1.SS0.SSS0.Px2.p1.m11" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}^{2}" display="inline"><msubsup><mi>𝐞</mi><mi>𝙰</mi><mn>2</mn></msubsup></math>, with <math id="A1.SS0.SSS0.Px2.p1.m12" class="ltx_math_unparsed" alttext="|\cdot|" display="inline"><mrow><mo fence="false" stretchy="false">|</mo><mo lspace="0em" rspace="0em">⋅</mo><mo fence="false" stretchy="false">|</mo></mrow></math> representing the edge’s length.</p>
</div>
</section>
<section id="A1.SS0.SSS0.Px3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Pattern 3</h5>

<div id="A1.SS0.SSS0.Px3.p1" class="ltx_para">
<p class="ltx_p">We first check if the patch contains even number of interior vertices.
Then, we look for an interior compatible edge pair <math id="A1.SS0.SSS0.Px3.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px3.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> whose adjacent two faces are both reversed.
If the adjacent vertices of <math id="A1.SS0.SSS0.Px3.p1.m3" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px3.p1.m4" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> are all interior, we return <math id="A1.SS0.SSS0.Px3.p1.m5" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math>.
Otherwise, if <math id="A1.SS0.SSS0.Px3.p1.m6" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px3.p1.m7" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> are both flippable and have corresponding opposite vertices which are both interior, we flip both of them and return <math id="A1.SS0.SSS0.Px3.p1.m8" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math>.</p>
</div>
</section>
<section id="A1.SS0.SSS0.Px4" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Pattern 4</h5>

<div id="A1.SS0.SSS0.Px4.p1" class="ltx_para">
<p class="ltx_p">We first check if the patch contains no interior vertices.
We then look for an interior compatible edge pair <math id="A1.SS0.SSS0.Px4.p1.m1" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{A}}" display="inline"><msub><mi>𝐞</mi><mi>𝙰</mi></msub></math> and <math id="A1.SS0.SSS0.Px4.p1.m2" class="ltx_Math" alttext="\mathbf{e}_{\mathtt{B}}" display="inline"><msub><mi>𝐞</mi><mi>𝙱</mi></msub></math> whose adjacent vertices all have interior angles larger than <math id="A1.SS0.SSS0.Px4.p1.m3" class="ltx_Math" alttext="\pi" display="inline"><mi>π</mi></math>.
If there is just one such edge pair in the patch, we return that edge.</p>
</div>
</section>
<section id="A1.SS0.SSS0.Px5" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Pattern 5</h5>

<div id="A1.SS0.SSS0.Px5.p1" class="ltx_para">
<p class="ltx_p">We match the given patch with the fixed mesh topology shown in the figure; i.e., the patch must have four faces, three interior edges, six boundary edges, five boundary vertices, and one interior vertex.
We then identify the “hourglass” vertex; i.e., one that is adjacent to four boundary edges.
Then we return an edge between the interior vertex and the hourglass vertex.</p>
</div>
</section>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Thu Nov 21 12:05:35 2024 by <a href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="Mascot Sammy"></a>
</div></footer>
</div>
</body>
</html>
